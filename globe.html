<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TriTree Planet – Hex Patch on Sphere</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --panel: #020617cc;
      --accent: #22d3ee;
      --accent-soft: #38bdf8;
      --text: #e5e7eb;
      --muted: #9ca3af;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #0f172a 0, #020617 55%);
      color: var(--text);
    }
    #app {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
    }
    #toolbar {
      padding: 10px 14px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      pointer-events: auto;
      background: linear-gradient(to bottom,
        rgba(15,23,42,0.9),
        rgba(15,23,42,0.72),
        rgba(15,23,42,0));
      z-index: 10;
    }
    #title {
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.02em;
      white-space: nowrap;
    }
    #hint {
      font-size: 12px;
      color: var(--muted);
    }
    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #02061799;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .pill span.key {
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      font-size: 10px;
      color: var(--accent-soft);
      font-weight: 500;
    }
    #three-container {
      flex: 1;
      position: relative;
    }
    #three-container canvas {
      display: block;
    }
    #metrics {
      position: absolute;
      right: 10px;
      bottom: 10px;
      padding: 6px 10px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid #1e293b;
      font-size: 11px;
      color: var(--muted);
      pointer-events: none;
      backdrop-filter: blur(10px);
      min-width: 150px;
    }
    #metrics strong {
      color: var(--accent-soft);
      font-weight: 500;
    }
  </style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <div id="title">TriTree Planet · Hex Patch on Sphere</div>
    <div id="hint" class="pill">
      <span class="key">Drag</span> orbit
      <span class="key">Wheel</span> zoom
      <span class="key">Shift + Drag</span> draw hex patch
    </div>
  </div>
  <div id="three-container">
    <div id="metrics">
      <div><strong>Tiles</strong> <span id="metric-tiles">–</span></div>
      <div><strong>Max level</strong> <span id="metric-level">–</span></div>
      <div><strong>Hex radius</strong> <span id="metric-hex">none</span></div>
    </div>
  </div>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';

  // ──────────────────────────────────────────────────────────────
  // Constants & helpers
  // ──────────────────────────────────────────────────────────────

  const PLANET_RADIUS = 1.0;
  const MAX_LEVEL = 4;            // Max tritree depth
  const BASE_RESOLUTION = 6;      // Barycentric grid resolution at level 0
  const RES_PER_LEVEL = 2;        // Extra resolution per level
  const DEG2RAD = Math.PI / 180;

  function sampleHeight(dir) {
    // Simple analytic height field so tiles visibly "protrude" from the sphere.
    // Uses direction components; continuous across tiles.
    const k = 6.0;
    const a = Math.sin(k * dir.x + 1.234);
    const b = Math.sin(k * dir.y * 1.3 + 2.345);
    const c = Math.sin(k * dir.z * 0.7 + 3.456);
    const h = (a + b + c) / 3;    // [-1, 1]
    return 0.05 * h;              // ±5% of radius
  }

  // ──────────────────────────────────────────────────────────────
  // Triangular tile (tritree leaf / node)
  // ──────────────────────────────────────────────────────────────

  class TriTile {
    constructor(v0, v1, v2, level = 0, index = 0, parent = null, radius = PLANET_RADIUS) {
      this.v0 = v0.clone().normalize();
      this.v1 = v1.clone().normalize();
      this.v2 = v2.clone().normalize();
      this.level = level;
      this.index = index;
      this.parent = parent;
      this.radius = radius;

      this.children = null;
      this.geometry = null;
      this.mesh = null;

      this.centerDir = new THREE.Vector3()
        .add(this.v0)
        .add(this.v1)
        .add(this.v2)
        .normalize();
      this.center = this.centerDir.clone().multiplyScalar(this.radius);

      const a0 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v0), -1, 1));
      const a1 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v1), -1, 1));
      const a2 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v2), -1, 1));
      this.angularRadius = Math.max(a0, a1, a2);
    }

    subdivide() {
      if (this.children) return this.children;

      const mid01 = new THREE.Vector3().addVectors(this.v0, this.v1).normalize();
      const mid12 = new THREE.Vector3().addVectors(this.v1, this.v2).normalize();
      const mid20 = new THREE.Vector3().addVectors(this.v2, this.v0).normalize();

      const childLevel = this.level + 1;
      this.children = [
        // center
        new TriTile(mid01, mid12, mid20, childLevel, this.index * 4, this, this.radius),
        // v0 corner
        new TriTile(this.v0, mid01, mid20, childLevel, this.index * 4 + 1, this, this.radius),
        // v1 corner
        new TriTile(this.v1, mid12, mid01, childLevel, this.index * 4 + 2, this, this.radius),
        // v2 corner
        new TriTile(this.v2, mid20, mid12, childLevel, this.index * 4 + 3, this, this.radius),
      ];
      return this.children;
    }

    buildGeometry() {
      if (this.geometry) return this.geometry;

      const res = Math.min(BASE_RESOLUTION + this.level * RES_PER_LEVEL, 20);
      const positions = [];
      const indices = [];

      const v0 = this.v0;
      const v1 = this.v1;
      const v2 = this.v2;

      // Barycentric subdivision on the sphere
      for (let i = 0; i <= res; i++) {
        for (let j = 0; j <= res - i; j++) {
          const k = res - i - j;
          const w0 = i / res;
          const w1 = j / res;
          const w2 = k / res;

          let px = w0 * v0.x + w1 * v1.x + w2 * v2.x;
          let py = w0 * v0.y + w1 * v1.y + w2 * v2.y;
          let pz = w0 * v0.z + w1 * v1.z + w2 * v2.z;

          const len = Math.sqrt(px * px + py * py + pz * pz) || 1;
          px /= len; py /= len; pz /= len;

          const dir = new THREE.Vector3(px, py, pz);
          const h = sampleHeight(dir);
          const r = this.radius * (1.0 + h);

          positions.push(
            dir.x * r,
            dir.y * r,
            dir.z * r
          );
        }
      }

      // Triangle indices (same layout as triangleWorker)
      let vIdx = 0;
      for (let i = 0; i < res; i++) {
        const rowStart = vIdx;
        const rowLen = res - i + 1;
        const nextRowStart = vIdx + rowLen;

        for (let j = 0; j < res - i; j++) {
          const a = rowStart + j;
          const b = rowStart + j + 1;
          const c = nextRowStart + j;

          indices.push(a, b, c);

          if (j < res - i - 1) {
            const d = nextRowStart + j + 1;
            indices.push(b, d, c);
          }
        }

        vIdx = nextRowStart;
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(positions, 3)
      );
      geom.setIndex(indices);
      geom.computeVertexNormals();
      geom.computeBoundingSphere();

      this.geometry = geom;
      return geom;
    }

    ensureMesh(scene, material) {
      if (!this.mesh) {
        this.buildGeometry();
        this.mesh = new THREE.Mesh(this.geometry, material);
        this.mesh.castShadow = false;
        this.mesh.receiveShadow = false;
        scene.add(this.mesh);
      }
    }

    setVisible(visible) {
      if (this.mesh) this.mesh.visible = visible;
    }

    hideDescendants() {
      if (!this.children) return;
      for (const child of this.children) {
        child.setVisible(false);
        child.hideDescendants();
      }
    }
  }

  // ──────────────────────────────────────────────────────────────
  // Icosahedron → root tiles
  // ──────────────────────────────────────────────────────────────

  function createIcosahedronTiles(radius = PLANET_RADIUS) {
    const t = (1 + Math.sqrt(5)) / 2;
    const verts = [
      new THREE.Vector3(-1,  t,  0).normalize(),
      new THREE.Vector3( 1,  t,  0).normalize(),
      new THREE.Vector3(-1, -t,  0).normalize(),
      new THREE.Vector3( 1, -t,  0).normalize(),

      new THREE.Vector3( 0, -1,  t).normalize(),
      new THREE.Vector3( 0,  1,  t).normalize(),
      new THREE.Vector3( 0, -1, -t).normalize(),
      new THREE.Vector3( 0,  1, -t).normalize(),

      new THREE.Vector3( t,  0, -1).normalize(),
      new THREE.Vector3( t,  0,  1).normalize(),
      new THREE.Vector3(-t,  0, -1).normalize(),
      new THREE.Vector3(-t,  0,  1).normalize(),
    ];

    const faces = [
      [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
      [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
      [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
      [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1],
    ];

    const tiles = [];
    for (let i = 0; i < faces.length; i++) {
      const [i0, i1, i2] = faces[i];
      tiles.push(
        new TriTile(verts[i0], verts[i1], verts[i2], 0, i, null, radius)
      );
    }
    return tiles;
  }

  // ──────────────────────────────────────────────────────────────
  // Tritree manager (simplified, efficiency‑aware)
  // ──────────────────────────────────────────────────────────────

  class SimpleTriTreeManager {
    constructor(scene, radius = PLANET_RADIUS) {
      this.scene = scene;
      this.radius = radius;
      this.rootTiles = createIcosahedronTiles(radius);
      this.material = new THREE.MeshStandardMaterial({
        color: 0x4b5563,
        metalness: 0.0,
        roughness: 0.9,
        flatShading: false,
      });
      this.hexPatch = null;
      this.visibleTileCount = 0;
      this.currentMaxLevel = 0;

      for (const tile of this.rootTiles) {
        tile.ensureMesh(this.scene, this.material);
        tile.setVisible(true);
      }
    }

    setHexPatch(centerDir, radius) {
      if (!centerDir || !Number.isFinite(radius) || radius <= 0) {
        this.hexPatch = null;
      } else {
        this.hexPatch = {
          centerDir: centerDir.clone().normalize(),
          radius,
        };
      }
    }

    shouldSplitTile(tile) {
      if (tile.level >= MAX_LEVEL) return false;
      const patch = this.hexPatch;
      if (!patch || !patch.centerDir) {
        // No hex yet: just keep level 0 tiles
        return false;
      }

      const centerDir = tile.centerDir;
      const patchDir = patch.centerDir;
      const patchRadius = patch.radius;

      const dot = THREE.MathUtils.clamp(centerDir.dot(patchDir), -1, 1);
      const angle = Math.acos(dot);

      // If the tile is fully outside the patch (with a small margin), don't split
      if (angle - tile.angularRadius > patchRadius * 1.1) {
        return false;
      }

      // Inside or intersecting the patch:
      // keep subdividing until tile angular radius is small compared
      // to the patch radius.
      const targetArc = patchRadius / 5; // roughly ~10 tiles across diameter
      return tile.angularRadius > targetArc * 1.1 && tile.level < MAX_LEVEL;
    }

    update(camera) {
      this.visibleTileCount = 0;
      this.currentMaxLevel = 0;
      for (const root of this.rootTiles) {
        this._updateTileLOD(root);
      }
    }

    _updateTileLOD(tile) {
      const split = this.shouldSplitTile(tile);

      if (split) {
        tile.subdivide();
        tile.setVisible(false);
        if (tile.children) {
          for (const child of tile.children) {
            child.ensureMesh(this.scene, this.material);
            child.setVisible(true);
            this.visibleTileCount++;
            this.currentMaxLevel = Math.max(this.currentMaxLevel, child.level);
            this._updateTileLOD(child);
          }
        }
      } else {
        tile.ensureMesh(this.scene, this.material);
        tile.setVisible(true);
        this.visibleTileCount++;
        this.currentMaxLevel = Math.max(this.currentMaxLevel, tile.level);
        if (tile.children) {
          for (const child of tile.children) {
            child.setVisible(false);
            child.hideDescendants();
          }
        }
      }
    }
  }

  // ──────────────────────────────────────────────────────────────
  // Scene / camera / renderer
  // ──────────────────────────────────────────────────────────────

  const container = document.getElementById('three-container');
  const metricsTiles = document.getElementById('metric-tiles');
  const metricsLevel = document.getElementById('metric-level');
  const metricsHex = document.getElementById('metric-hex');

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color('#020617');

  const camera = new THREE.PerspectiveCamera(
    45,
    container.clientWidth / container.clientHeight,
    0.1,
    50
  );
  camera.position.set(0, 0, 3.5);
  camera.lookAt(0, 0, 0);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 1.2;
  controls.maxDistance = 6.0;

  // Lights
  const hemi = new THREE.HemisphereLight(0x93c5fd, 0x020617, 0.6);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(3, 4, 2);
  scene.add(dir);

  // ──────────────────────────────────────────────────────────────
  // Tritree planet
  // ──────────────────────────────────────────────────────────────

  const triTree = new SimpleTriTreeManager(scene, PLANET_RADIUS);

  // ──────────────────────────────────────────────────────────────
  // Hex patch on the planet (Shift + drag)
  // ──────────────────────────────────────────────────────────────

  const raycaster = new THREE.Raycaster();
  const mouseNDC = new THREE.Vector2();

  const hexGeometry = new THREE.BufferGeometry();
  const hexMaterial = new THREE.LineBasicMaterial({
    color: 0x22d3ee,
    linewidth: 2
  });
  const hexLine = new THREE.LineLoop(hexGeometry, hexMaterial);
  hexLine.visible = false;
  scene.add(hexLine);

  const hexPatch = {
    centerDir: null,
    radius: 0
  };

  let drawingHex = false;

  function getSphereIntersection(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    mouseNDC.set(x, y);

    raycaster.setFromCamera(mouseNDC, camera);
    const origin = raycaster.ray.origin.clone();
    const dirRay = raycaster.ray.direction.clone().normalize();

    // Ray-sphere intersection (center at 0, radius PLANET_RADIUS)
    const oc = origin; // since center is (0,0,0)
    const b = oc.dot(dirRay);
    const c = oc.lengthSq() - PLANET_RADIUS * PLANET_RADIUS;
    const disc = b * b - c;
    if (disc < 0) return null;
    let t = -b - Math.sqrt(disc);
    if (t < 0) t = -b + Math.sqrt(disc);
    if (t < 0) return null;
    return origin.add(dirRay.multiplyScalar(t));
  }

  function updateHexVisualization() {
    if (!hexPatch.centerDir || hexPatch.radius <= 0) {
      hexLine.visible = false;
      metricsHex.textContent = 'none';
      triTree.setHexPatch(null, 0);
      return;
    }

    const segments = 6;
    const positions = new Float32Array((segments + 1) * 3);
    const c = hexPatch.centerDir.clone().normalize();
    const r = hexPatch.radius;

    // Build tangent basis (east/north) around centerDir
    let up = new THREE.Vector3(0, 1, 0);
    if (Math.abs(up.dot(c)) > 0.98) {
      up = new THREE.Vector3(1, 0, 0);
    }
    const east = new THREE.Vector3().crossVectors(up, c).normalize();
    const north = new THREE.Vector3().crossVectors(c, east).normalize();

    for (let k = 0; k < segments; k++) {
      const phi = (Math.PI / 3) * k; // flat‑top hex
      const tangent = new THREE.Vector3()
        .copy(east).multiplyScalar(Math.cos(phi))
        .add(new THREE.Vector3().copy(north).multiplyScalar(Math.sin(phi)));

      const dir = new THREE.Vector3()
        .copy(c).multiplyScalar(Math.cos(r))
        .add(tangent.multiplyScalar(Math.sin(r)))
        .normalize();

      const i3 = k * 3;
      positions[i3 + 0] = dir.x * PLANET_RADIUS * 1.001;
      positions[i3 + 1] = dir.y * PLANET_RADIUS * 1.001;
      positions[i3 + 2] = dir.z * PLANET_RADIUS * 1.001;

      if (k === 0) {
        // close the loop at the end
        const j3 = segments * 3;
        positions[j3 + 0] = positions[i3 + 0];
        positions[j3 + 1] = positions[i3 + 1];
        positions[j3 + 2] = positions[i3 + 2];
      }
    }

    hexGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    hexGeometry.computeBoundingSphere();
    hexLine.visible = true;

    metricsHex.textContent = (hexPatch.radius / DEG2RAD).toFixed(1) + '°';
    triTree.setHexPatch(hexPatch.centerDir, hexPatch.radius);
  }

  function onPointerDown(e) {
    if (e.button !== 0 || !e.shiftKey) return;
    const hit = getSphereIntersection(e);
    if (!hit) return;
    e.preventDefault();
    drawingHex = true;
    controls.enabled = false;
    hexPatch.centerDir = hit.clone().normalize();
    hexPatch.radius = 0.0;
    updateHexVisualization();
  }

  function onPointerMove(e) {
    if (!drawingHex) return;
    const hit = getSphereIntersection(e);
    if (!hit) return;
    const dir = hit.clone().normalize();
    const dot = THREE.MathUtils.clamp(hexPatch.centerDir.dot(dir), -1, 1);
    let angle = Math.acos(dot);
    const minAngle = 3 * DEG2RAD;
    const maxAngle = 60 * DEG2RAD;
    angle = THREE.MathUtils.clamp(angle, minAngle, maxAngle);
    hexPatch.radius = angle;
    updateHexVisualization();
  }

  function onPointerUp(e) {
    if (!drawingHex) return;
    drawingHex = false;
    controls.enabled = true;
  }

  renderer.domElement.addEventListener('pointerdown', onPointerDown);
  renderer.domElement.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);

  // ──────────────────────────────────────────────────────────────
  // Resize & animation loop
  // ──────────────────────────────────────────────────────────────

  function onResize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }
  window.addEventListener('resize', onResize);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    triTree.update(camera);

    metricsTiles.textContent = triTree.visibleTileCount.toString();
    metricsLevel.textContent = triTree.currentMaxLevel.toString();

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
