<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NKN + OSM + Three.js ‚Äî Hex draw + Equilateral Tri Mesh + Texture Overlay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet (OSM) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet.draw (we extend it with L.Draw.Hexagon) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- NKN SDK UMD (global `nkn`) with fallback -->
  <script src="https://cdn.jsdelivr.net/gh/nknorg/nkn-sdk-js/dist/nkn.min.js"
          onerror="(function(){var s=document.createElement('script');s.src='https://unpkg.com/nkn-sdk/dist/nkn.min.js';document.head.appendChild(s);}())"></script>

  <!-- three.js via importmap (latest) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@latest/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
    }
  }
  </script>

  <style>
    *{box-sizing: border-box;}
    a{color:var(--accent);text-decoration:none}
    :root { --bg:#0b0f14; --card:#121923; --ink:#e8eef7; --muted:#9eb0c7; --accent:#6ee7ff; --ok:#7ee787; --bad:#ff6b6b; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu;}
    .wrap{max-width:1200px;margin:24px auto;padding:16px}
    .grid{display:grid;grid-template-columns:1.1fr 1fr;gap:16px}
    .card{background:var(--card);border:1px solid #1e2a36;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:16px}
    h1{font-size:20px;margin:0 0 10px}
    label{display:block;margin:10px 0 6px;color:var(--muted)}
    input[type=text], input[type=number], textarea{
      width:100%;padding:10px 12px;border-radius:12px;border:1px solid #2a3a4e;background:#0e1420;color:var(--ink);outline:none}
    textarea{min-height:120px;max-height:300px}
    input:focus, textarea:focus{border-color:var(--accent)}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;align-items:end}
    .row2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .btn{margin-top:10px;display:inline-flex;align-items:center;gap:8px;border:1px solid #2a3a4e;background:#0e1420;color:var(--ink);padding:9px 12px;border-radius:12px;cursor:pointer}
    .btn[disabled]{opacity:.55;cursor:not-allowed}
    .btn:hover{border-color:var(--accent)}
    .status{margin-top:8px;font-size:12px;color:var(--muted)}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;background:#0e1420;border:1px solid #2a3a4e}
    pre{white-space:pre-wrap;background:#0c1118;border:1px solid #1f2c3b;border-radius:12px;padding:12px;max-height:260px;overflow:auto}
    .ok{color:var(--ok)} .bad{color:var(--bad)}
    #map{height:420px;border-radius:12px;overflow:hidden;border:1px solid #1e2a36}
    #threeWrap{height:500px;border-radius:12px;overflow:hidden;border:1px solid #1e2a36;background:#0c1118}
    .rangeRow{display:grid;grid-template-columns:auto 1fr auto;gap:10px;align-items:center}
    input[type=range]{width:100%}
    .muted{color:var(--muted);font-size:12px}
    .modeToggle{display:inline-flex;gap:8px;align-items:center;margin-bottom:8px;}
  </style>
</head>
<body>
<div class="wrap">
  <h1>NKN Elevation Topo ‚Äî Hex draw + Equilateral Triangulation + Map Texture Overlay</h1>
  <a href="https://www.opentopodata.org/datasets/mapzen/" target="_blank"><h3>Fetch and host the mapzen open topo data ~ 1.7 TB</h3></a>
  <div class="grid">
    <div class="card">
      <div class="row2">
        <div>
          <label for="relay">Relay address (saved)</label>
          <input id="relay" type="text" placeholder="forwarder.‚Ä¶ or pubkey" />
        </div>
        <div>
          <label for="dataset">Dataset</label>
          <input id="dataset" type="text" value="mapzen" />
        </div>
      </div>

      <div class="row3">
        <div>
          <label for="nx">Rows (approx)</label>
          <input id="nx" type="number" min="0" max="4096" step="1" value="0" />
        </div>
        <div>
          <label for="ny">Cols (approx)</label>
          <input id="ny" type="number" min="0" max="4096" step="1" value="0" />
        </div>
        <div>
          <label for="zScale">Z exaggeration</label>
          <input id="zScale" type="number" step="0.1" value="1.0" />
        </div>
      </div>

      <label>Grid spacing (meters)</label>
      <div class="rangeRow">
        <span class="muted">5m</span>
        <input id="spacing" type="range" min="5" max="500" step="5" value="50" />
        <span id="spacingVal" class="muted">50 m</span>
      </div>
      <div class="muted">Click ‚ÄúDraw hexagon‚Äù, click once to set center, <b>drag outward</b> to size, release to finalize. Spacing sets equilateral-tri lattice density.</div>

      <div class="row2">
        <button id="regenBtn" class="btn">üîÅ Regenerate from spacing</button>
        <button id="drawBtn" class="btn">‚¨¢ Draw hexagon</button>
      </div>

      <div class="row2">
        <button id="locBtn" class="btn">üìç Use my location</button>
        <button id="queryBtn" class="btn" disabled>üöÄ Query progressive elevation via NKN</button>
      </div>

      <div class="modeToggle">
        <button id="toggleModeBtn" class="btn">üì¶ Send as: Geohash</button>
        <span id="modeHint" class="muted">Toggle to switch between geohash and lat/lng payloads.</span>
      </div>

      <label>Texture overlay</label>
      <div class="row2">
        <button id="textureToggleBtn" class="btn">üñºÔ∏è Overlay map texture: Off</button>
        <input id="tileTemplate" type="text" value="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
      </div>
      <div class="muted">Tile server must allow CORS for canvas extraction. Keep {s},{z},{x},{y}. Toggle to remove.</div>

      <div id="map"></div>

      <label for="pointsBox">Bulk points (pipe-separated: <code>lat,lng|lat,lng|‚Ä¶</code>)</label>
      <textarea id="pointsBox" placeholder="lat,lng|lat,lng|‚Ä¶"></textarea>

      <div class="status">
        <div>My NKN address: <span id="myAddr" class="tag">‚Äî</span></div>
        <div>Connection: <span id="conn" class="tag">initializing‚Ä¶</span></div>
        <div id="sdkStatus" class="status">Loading nkn-sdk‚Ä¶</div>
        <div id="pointCount" class="status"></div>
        <div id="progress" class="status"></div>
        <div id="levelInfo" class="status"></div>
        <div id="texInfo" class="status"></div>
      </div>

      <label>Logs</label>
      <pre id="log"></pre>
    </div>

    <div class="card">
      <label>3D Topography (equilateral triangle mesh; hex footprint)</label>
      <div id="threeWrap"></div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

(function(){
  // ---------- DOM ----------
  const logEl = document.getElementById('log');
  const relayEl = document.getElementById('relay');
  const datasetEl = document.getElementById('dataset');
  const nxEl = document.getElementById('nx');
  const nyEl = document.getElementById('ny');
  const zScaleEl = document.getElementById('zScale');
  const spacingEl = document.getElementById('spacing');
  const spacingVal = document.getElementById('spacingVal');
  const locBtn = document.getElementById('locBtn');
  const drawBtn = document.getElementById('drawBtn');
  const regenBtn = document.getElementById('regenBtn');
  const queryBtn = document.getElementById('queryBtn');
  const myAddrEl = document.getElementById('myAddr');
  const connEl = document.getElementById('conn');
  const sdkStatus = document.getElementById('sdkStatus');
  const pointsBox = document.getElementById('pointsBox');
  const pointCountEl = document.getElementById('pointCount');
  const progressEl = document.getElementById('progress');
  const levelInfoEl = document.getElementById('levelInfo');
  const texInfoEl = document.getElementById('texInfo');
  const threeWrap = document.getElementById('threeWrap');
  const toggleModeBtn = document.getElementById('toggleModeBtn');
  const modeHint = document.getElementById('modeHint');
  const textureToggleBtn = document.getElementById('textureToggleBtn');
  const tileTemplateEl = document.getElementById('tileTemplate');

  // ---------- meters-per-degree helpers ----------
  function metersPerDegLat(phiRad){
    return 111132.954 - 559.822*Math.cos(2*phiRad) + 1.175*Math.cos(4*phiRad) - 0.0023*Math.cos(6*phiRad);
  }
  function metersPerDegLon(phiRad){
    return 111412.84*Math.cos(phiRad) - 93.5*Math.cos(3*phiRad) + 0.118*Math.cos(5*phiRad);
  }

  // ---------- Web Mercator helpers for tiling ----------
  const TILE = 256;
  function lon2x(lon, z){ return ((lon + 180) / 360) * (TILE * (1<<z)); }
  function lat2y(lat, z){
    const s = Math.sin(lat * Math.PI/180);
    return (0.5 - Math.log((1+s)/(1-s)) / (4*Math.PI)) * (TILE * (1<<z));
  }
  function groundResMpp(lat, z){
    const C = 40075016.68557849; // eq. circumference (m)
    return Math.cos(lat*Math.PI/180) * C / (TILE * (1<<z));
  }
  function pickZoomForTarget(lat, targetMpp, maxTexDim, hexLatLngs){
    let best = 19;
    for (let z=19; z>=0; z--){
      const mpp = groundResMpp(lat, z);
      // compute bbox pixels at this z
      let minx=Infinity,maxx=-Infinity,miny=Infinity,maxy=-Infinity;
      for (const ll of hexLatLngs){
        const px = lon2x(ll.lng, z);
        const py = lat2y(ll.lat, z);
        if (px<minx) minx=px; if (px>maxx) maxx=px;
        if (py<miny) miny=py; if (py>maxy) maxy=py;
      }
      const W = Math.ceil(maxx-minx), H = Math.ceil(maxy-miny);
      if (mpp <= targetMpp && W<=maxTexDim && H<=maxTexDim){ best = z; break; }
    }
    return best;
  }

  // ---------- Mode toggle (persisted) ----------
  const LS_RELAY='nkn.forwarder.dest', LS_DATASET='nkn.forwarder.dataset', LS_MODE='nkn.forwarder.mode';
  relayEl.value = localStorage.getItem(LS_RELAY) || '';
  datasetEl.value = localStorage.getItem(LS_DATASET) || (datasetEl.value || 'mapzen');
  relayEl.addEventListener('change', ()=>localStorage.setItem(LS_RELAY, relayEl.value.trim()));
  datasetEl.addEventListener('change', ()=>localStorage.setItem(LS_DATASET, datasetEl.value.trim()));
  let SEND_MODE = localStorage.getItem(LS_MODE) || 'geohash';
  function renderMode(){
    toggleModeBtn.textContent = (SEND_MODE==='geohash') ? 'üì¶ Send as: Geohash' : 'üì¶ Send as: Lat/Lng';
    modeHint.textContent = (SEND_MODE==='geohash')
      ? 'Using geohash payloads (compact). Click to switch to lat/lng.'
      : 'Using lat/lng payloads. Click to switch to geohash.';
  }
  renderMode();
  toggleModeBtn.addEventListener('click', ()=>{
    SEND_MODE = (SEND_MODE==='geohash') ? 'latlng' : 'geohash';
    localStorage.setItem(LS_MODE, SEND_MODE);
    renderMode();
  });

  // ---------- utils ----------
  function log(...args){
    const line = args.map(a => typeof a === 'string' ? a : JSON.stringify(a, null, 2)).join(' ');
    logEl.textContent += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log(...args);
  }
  function setConn(txt, ok){
    connEl.textContent = txt;
    connEl.style.borderColor = ok ? 'rgba(126,231,135,.6)' : '#2a3a4e';
    connEl.style.color = ok ? 'var(--ok)' : 'var(--muted)';
    queryBtn.disabled = !ok;
  }
  function requireSDK(){
    if (!window.nkn || !nkn.MultiClient) {
      sdkStatus.innerHTML = '<span class="bad">nkn-sdk not loaded. Check CDN.</span>';
      throw new Error('nkn-sdk not loaded');
    }
    sdkStatus.innerHTML = '<span class="ok">nkn-sdk loaded.</span>';
  }
  function splitTokens(text){
    if (!text) return [];
    return text.replace(/\r/g,'').split(/\s*\|\s*|\n+/).map(s=>s.trim()).filter(Boolean);
  }
  function countPointsBox(){
    const n = splitTokens(pointsBox.value).length;
    pointCountEl.textContent = n ? (n + ' points prepared (equilateral tri lattice)') : '';
  }
  spacingVal.textContent = `${spacingEl.value} m`;
  spacingEl.addEventListener('input', ()=>{
    spacingVal.textContent = `${spacingEl.value} m`;
    if (lastHex) generateHexGrid(lastHex);
  });

  // ---------- Geohash ----------
  const GH32 = '0123456789bcdefghjkmnpqrstuvwxyz';
  function geohashEncode(lat, lon, precision=9){
    let bit=0, even=true, latMin=-90,latMax=90,lonMin=-180,lonMax=180, ch=0, hash='';
    while (hash.length < precision){
      if (even){ const mid=(lonMin+lonMax)/2; if (lon > mid){ ch |= (1<<(4-bit)); lonMin=mid; } else { lonMax=mid; } }
      else { const mid=(latMin+latMax)/2; if (lat > mid){ ch |= (1<<(4-bit)); latMin=mid; } else { latMax=mid; } }
      even=!even;
      if (bit<4){ bit++; } else { hash += GH32[ch]; bit=0; ch=0; }
    }
    return hash;
  }
  function pickGeohashPrecision(spacingM){
    if (spacingM >= 1500) return 6;
    if (spacingM >= 300)  return 7;
    if (spacingM >= 60)   return 8;
    if (spacingM >= 10)   return 9;
    return 10;
  }

  // ---------- Leaflet map ----------
  let map, meMarker, hexLayer=null, lastHex=null;

  function initMap(){
    map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);
    map.setView([37.7749, -122.4194], 11);
  }

  function useMyLocation(){
    if (!navigator.geolocation) { log('‚ö†Ô∏è Geolocation not available'); return; }
    navigator.geolocation.getCurrentPosition(pos=>{
      const { latitude:lat, longitude:lng } = pos.coords;
      map.setView([lat,lng], 12);
      if (meMarker) { map.removeLayer(meMarker); }
      meMarker = L.marker([lat,lng]).addTo(map).bindPopup('You are here').openPopup();
    }, err=> log('‚ö†Ô∏è Geolocation error:', err.message||err));
  }

  // ---------- Custom Leaflet.draw tool: L.Draw.Hexagon (center-drag) ----------
  (function(){
    const SimpleShape = L.Draw.SimpleShape || L.Draw.Rectangle.prototype;

    L.Draw.Hexagon = SimpleShape.extend({
      statics: { TYPE: 'hexagon' },
      options: { shapeOptions: { color:'#6ee7ff', weight:2 } },

      initialize: function(map, options){
        this.type = L.Draw.Hexagon.TYPE;
        L.Draw.SimpleShape.prototype.initialize.call(this, map, options);
      },

      _drawShape: function(latlng){
        const center = this._startLatLng;
        const phiC = center.lat * Math.PI/180;
        const mDegLatC = metersPerDegLat(phiC);
        const xM = (latlng.lng - center.lng) * metersPerDegLon(phiC);
        const yM = (latlng.lat - center.lat) * mDegLatC;
        const a = Math.max(5, Math.hypot(xM, yM)); // apothem (m)
        this._lastApothemM = a;
        const R = 2 * a / Math.sqrt(3);

        const verts = [];
        for (let k=0;k<6;k++){
          const th = (Math.PI/3)*k;          // flat-top
          const vx = R*Math.cos(th), vy = R*Math.sin(th); // meters
          const latV = center.lat + vy / mDegLatC;
          const phiV = latV * Math.PI/180;
          const mDegLonV = metersPerDegLon(phiV);
          const lngV = center.lng + vx / mDegLonV;
          verts.push([latV, lngV]);
        }

        if (!this._shape){
          this._shape = L.polygon(verts, this.options.shapeOptions);
          this._map.addLayer(this._shape);
        } else {
          this._shape.setLatLngs(verts);
        }
      },

      _fireCreatedEvent: function(){
        const layer = L.polygon(this._shape.getLatLngs(), this.options.shapeOptions);
        layer._hexCenter = this._startLatLng;
        layer._apothemM  = this._lastApothemM || 0;
        L.Draw.Feature.prototype._fireCreatedEvent.call(this, layer);
      }
    });
  })();

  let drawHandler = null;
  function startDrawHexagon(){
    if (!drawHandler) drawHandler = new L.Draw.Hexagon(map, { shapeOptions: { color:'#6ee7ff', weight:2 } });
    drawHandler.enable();
  }

  // ---------- Triangular lattice in hex (equilateral) ----------
  function generateHexGrid(hex){
    if (!hex) return;
    const { center:{lat:lat0, lng:lng0}, apothemM:a } = hex;
    const phi0 = lat0 * Math.PI/180;
    const mDegLatC = metersPerDegLat(phi0);

    const d  = Math.max(1, parseFloat(spacingEl.value||'50'));  // side length (m)
    const ry = Math.sqrt(3)/2 * d;                              // row height
    const R  = 2 * a / Math.sqrt(3);                            // hex circumradius (m)
    const Xmax = R, Ymax = a;

    const C30 = Math.cos(Math.PI/6), S30 = Math.sin(Math.PI/6);
    function insideHex(x,y){
      if (Math.abs(y) > Ymax) return false;
      if (Math.abs( x*C30 + y*S30 ) > Ymax) return false;
      if (Math.abs(-x*C30 + y*S30 ) > Ymax) return false;
      return true;
    }

    const ptsLocal = [];
    const rows = new Map(); // i -> array of points
    const iMax = Math.floor(Ymax / ry);
    for (let i = -iMax; i <= iMax; i++){
      const y = i * ry;
      const lat = lat0 + y / mDegLatC;             // per-row latitude
      const phiRow = lat * Math.PI/180;
      const mDegLonRow = metersPerDegLon(phiRow);  // per-row meters/deg (lon)
      const xOffset = (i & 1) ? 0.5 * d : 0.0;
      const jMin = Math.ceil((-Xmax - xOffset) / d);
      const jMax = Math.floor(( Xmax - xOffset) / d);

      const row = [];
      for (let j=jMin; j<=jMax; j++){
        const x = j*d + xOffset;
        if (!insideHex(x,y)) continue;
        const lng = lng0 + x / mDegLonRow;
        const p = { i, j, x, y, lat, lng };
        row.push(p);
        ptsLocal.push(p);
      }
      if (row.length) rows.set(i, row);
    }

    nxEl.value = String(rows.size);
    nyEl.value = String(Math.max(...[...rows.values()].map(r=>r.length)));
    pointsBox.value = ptsLocal.map(p=>`${p.lat.toFixed(6)},${p.lng.toFixed(6)}`).join('|');
    countPointsBox();

    if (!hexLayer){
      const RdegX = R / metersPerDegLon(phi0), RdegY = Ymax / mDegLatC;
      map.fitBounds([[lat0-RdegY, lng0-RdegX], [lat0+RdegY, lng0+RdegX]], { padding:[20,20] });
    }

    log(`üßÆ Hex lattice: rows=${rows.size}, max cols‚âà${nyEl.value}, points=${ptsLocal.length}, spacing (side)=${d}m`);
  }

  // ---------- NKN ----------
  const pending = new Map();
  let thePayloadBytes = 0;
  function uuidv4(){
    if (crypto.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
      const r = Math.random()*16|0, v = c==='x'?r:(r&0x3|0x8); return v.toString(16);
    });
  }
  function sendWithReply(mc, dest, obj, timeoutMs=25000) {
    const id = obj.id || uuidv4(); obj.id = id;
    thePayloadBytes = new TextEncoder().encode(JSON.stringify(obj)).length;
    const p = new Promise((resolve, reject)=>{
      const t = setTimeout(()=>{ pending.delete(id); reject(new Error('DM reply timeout')); }, timeoutMs);
      pending.set(id, { resolve, timeout: t });
    });
    mc.send(dest, JSON.stringify(obj)).then(()=>{
      log('üì§ sent DM', { id, bytes: thePayloadBytes, dest });
    }).catch(err=>{
      const st = pending.get(id); if (st){ clearTimeout(st.timeout); pending.delete(id); }
      log('‚ùå send error:', err && err.message || err);
    });
    return p;
  }
  function handleIncoming(src, payload){
    const text = (typeof payload==='string') ? payload : new TextDecoder().decode(payload);
    let msg; try { msg = JSON.parse(text); } catch { log('üì• incoming (raw):', text); return; }
    if (msg && msg.type === 'http.response' && msg.id && pending.has(msg.id)) {
      const st = pending.get(msg.id); clearTimeout(st.timeout); pending.delete(msg.id); st.resolve(msg); return;
    }
    log('üì• unsolicited from', src, msg);
  }

  // ---------- Three.js (equilateral triangulation) ----------
  let renderer, camera, controls, scene, mesh, geom, posAttr, colorAttr, elevs, isFinal, minY, maxY;
  let pts = [];                 // [{i,j,x,y,lat,lng}, ...]
  let idxByLL, idxByGH;
  let neighbors = [];
  let overlayOn = false, currentTexture = null, currentZoom = 0;

  function initThree(){
    const w = threeWrap.clientWidth, h = threeWrap.clientHeight;
    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(w, h);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    threeWrap.innerHTML = '';
    threeWrap.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c1118);

    camera = new THREE.PerspectiveCamera(50, w/h, 0.1, 1e7);
    camera.position.set(0, 800, 800);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,0,0);
    controls.update();

    const hemi = new THREE.HemisphereLight(0xffffff, 0x404040, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(500, 1000, 500);
    scene.add(dir);

    animate();
    window.addEventListener('resize', onResize);
  }
  function onResize(){
    const w = threeWrap.clientWidth, h = threeWrap.clientHeight;
    if (!renderer) return;
    renderer.setSize(w, h);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  let lastSmoothMS = 0;
  const SMOOTH_INTERVAL_MS = 45;
  const SMOOTH_PASSES_PER_TICK = 1;
  function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    if (geom && now - lastSmoothMS >= SMOOTH_INTERVAL_MS) {
      smoothUnknowns(SMOOTH_PASSES_PER_TICK);
      geom.computeVertexNormals();
      lastSmoothMS = now;
    }
    if (renderer && scene && camera) renderer.render(scene, camera);
  }

  function buildHexMesh(points){
    pts = points.slice();
    const N = pts.length;

    const pos = new Float32Array(N*3);
    let minX=+Infinity, maxX=-Infinity, minZ=+Infinity, maxZ=-Infinity;
    for (let k=0;k<N;k++){
      const i3 = k*3;
      pos[i3+0] = pts[k].x;
      pos[i3+1] = 0;
      pos[i3+2] = -pts[k].y;
      if (pos[i3+0]<minX) minX=pos[i3+0]; if (pos[i3+0]>maxX) maxX=pos[i3+0];
      if (pos[i3+2]<minZ) minZ=pos[i3+2]; if (pos[i3+2]>maxZ) maxZ=pos[i3+2];
    }
    const cx = 0.5*(minX+maxX), cz = 0.5*(minZ+maxZ);
    for (let k=0;k<N;k++){ pos[k*3+0]-=cx; pos[k*3+2]-=cz; }

    const rows = new Map(); // i -> Map(j -> idx)
    for (let idx=0; idx<N; idx++){
      const {i,j} = pts[idx];
      if (!rows.has(i)) rows.set(i, new Map());
      rows.get(i).set(j, idx);
    }
    const has = (i,j)=> rows.has(i) && rows.get(i).has(j) ? rows.get(i).get(j) : undefined;

    const tris = [];
    for (const i of [...rows.keys()].sort((a,b)=>a-b)){
      const cols = [...rows.get(i).keys()].sort((a,b)=>a-b);
      for (const j of cols){
        const a = has(i, j);
        const b = has(i, j+1);
        if ((i & 1) === 0){
          const c = has(i+1, j);
          const d = has(i+1, j+1);
          if (a!=null && b!=null && d!=null) tris.push(a, b, d);
          if (a!=null && d!=null && c!=null) tris.push(a, d, c);
        } else {
          const c = has(i+1, j-1);
          const d = has(i+1, j);
          if (a!=null && b!=null && d!=null) tris.push(a, b, d);
          if (a!=null && d!=null && c!=null) tris.push(a, d, c);
        }
      }
    }

    const colors = new Float32Array(N*3);
    for (let k=0;k<N;k++){ colors[k*3+0]=0.22; colors[k*3+1]=0.26; colors[k*3+2]=0.36; }

    geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geom.setIndex(tris);
    geom.computeVertexNormals();

    posAttr   = geom.getAttribute('position');
    colorAttr = geom.getAttribute('color');

    const mat = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide, vertexColors: true, roughness: 0.92, metalness: 0.0, map: null });
    if (mesh) { scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose(); }
    mesh = new THREE.Mesh(geom, mat);
    scene.add(mesh);

    const widthM  = (maxX - minX) || 1;
    const heightM = (maxZ - minZ) || 1;
    const maxSpan = Math.max(widthM, heightM);
    controls.target.set(0,0,0);
    camera.position.set(0, Math.max(800, maxSpan*0.9), Math.max(800, maxSpan*0.9));
    controls.update();

    elevs   = new Array(N).fill(NaN);
    isFinal = new Array(N).fill(false);
    minY = +Infinity; maxY = -Infinity;

    neighbors = Array.from({length:N}, ()=>new Set());
    const idx = geom.getIndex().array;
    for (let t=0;t<idx.length;t+=3){
      const a=idx[t], b=idx[t+1], c=idx[t+2];
      neighbors[a].add(b); neighbors[a].add(c);
      neighbors[b].add(a); neighbors[b].add(c);
      neighbors[c].add(a); neighbors[c].add(b);
    }

    // if overlay was on, rebuild texture for new geometry
    if (overlayOn) buildAndApplyTexture().catch(err=>{
      log('‚ö†Ô∏è texture rebuild failed:', err?.message||err);
    });

    // sanity: mean edge length
    let E=0, S=0;
    const v = pos;
    const dist = (p,q)=>{
      const ax=v[p*3], ay=v[p*3+2], bx=v[q*3], by=v[q*3+2];
      return Math.hypot(ax-bx, ay-by);
    };
    for (let n=0;n<neighbors.length;n++){
      for (const m of neighbors[n]){ E++; S += dist(n, m); }
    }
    if (E>0) log(`üî∫ mean edge ‚âà ${(S/E).toFixed(2)} m`);
  }

  function updateVertexColor(k, y){
    if (y<minY) minY=y;
    if (y>maxY) maxY=y;
    const t = (maxY===minY) ? 0.5 : (y - minY) / (maxY - minY);
    const i3 = k*3;
    let r,g,b;
    if (t < 0.25) { r=0.1; g=0.2+t; b=0.6 + t*0.6; }
    else if (t < 0.5) { r=0.1 + (t-0.25)*1.2; g=0.8; b=0.2; }
    else if (t < 0.8) { r=0.5 + (t-0.5)*1.0; g=0.35 + (t-0.5)*0.4; b=0.2; }
    else { r=1; g=1; b=1; }
    colorAttr.array[i3+0]=r; colorAttr.array[i3+1]=g; colorAttr.array[i3+2]=b;
  }

  function nearestAnchorFill(){
    const N = pts.length;
    const nearest = new Int32Array(N).fill(-1);
    const q = new Int32Array(N); let qh=0, qt=0;
    for (let i=0;i<N;i++){ if (isFinal[i]){ nearest[i]=i; q[qt++]=i; } }
    if (qt===0) return;
    while (qh<qt){
      const i=q[qh++], src=nearest[i];
      for (const nb of neighbors[i]){
        const j = nb|0;
        if (nearest[j]!==-1) continue;
        nearest[j]=src; q[qt++]=j;
      }
    }
    let any=false;
    for (let i=0;i<N;i++){
      if (isFinal[i]) continue;
      const src = nearest[i]; if (src<0) continue;
      const z = elevs[src];
      if (Number.isFinite(z)){
        elevs[i] = z;
        posAttr.array[i*3+1] = z;
        updateVertexColor(i, z);
        any=true;
      }
    }
    if (any){ posAttr.needsUpdate = true; colorAttr.needsUpdate = true; }
  }

  function smoothUnknowns(iterations=1){
    for (let it=0; it<iterations; it++){
      for (let i=0; i<pts.length; i++){
        if (isFinal[i]) continue;
        let sum=0, cnt=0;
        for (const nb of neighbors[i]){
          const v = elevs[nb];
          if (Number.isFinite(v)){ sum+=v; cnt++; }
        }
        if (cnt>=2){
          const v = sum/cnt;
          elevs[i] = v;
          posAttr.array[i*3+1] = v;
          updateVertexColor(i, v);
        }
      }
    }
    posAttr.needsUpdate = true;
    colorAttr.needsUpdate = true;
  }

  // ---------- Progressive schedule over triangular lattice ----------
  function highestPow2LE(n){ return 1 << Math.floor(Math.log2(Math.max(1,n))); }
  function axialDistance(i,j){ return (Math.abs(i) + Math.abs(j) + Math.abs(i+j)) / 2; }
  function buildProgressiveIndexLevelsTri(points){
    let Imax=0, Jmax=0;
    for (const p of points){ Imax=Math.max(Imax, Math.abs(p.i)); Jmax=Math.max(Jmax, Math.abs(p.j)); }
    const base = highestPow2LE(Math.max(1, Math.min(Imax, Jmax)));
    const strides = []; for (let s=base; s>=1; s>>=1) strides.push(s);

    const scheduled = new Uint8Array(points.length);
    const orderWithin = (A,B)=>{
      const a = points[A], b = points[B];
      const da = axialDistance(a.i, a.j), db = axialDistance(b.i, b.j);
      if (da!==db) return da-db;
      return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);
    };

    const levels = [];
    for (const s of strides){
      const lv = [];
      for (let idx=0; idx<points.length; idx++){
        if (scheduled[idx]) continue;
        const p = points[idx];
        if ( (p.i % s)===0 && (p.j % s)===0 ){ lv.push(idx); scheduled[idx]=1; }
      }
      lv.sort(orderWithin);
      levels.push(lv);
    }
    return levels;
  }

  // ---------- Batching for progressive requests (DM size budgeting) ----------
  const DM_BUDGET_BYTES = 2800;   // conservative payload budget per DM
  const MAX_LOCS_HARD   = 800;    // hard cap for locations per message
  function byteLen(obj){ return new TextEncoder().encode(JSON.stringify(obj)).length; }

  function indicesToBatchesLatLng(dataset, indices, toLatLng){
    const batches = [];
    let cur = [], curBytes = 0;
    for (const idx of indices){
      const loc = toLatLng(idx);
      const candidate = { type:'elev.query', dataset, locations: cur.concat([loc]) };
      const blen = byteLen(candidate);
      if (blen<=DM_BUDGET_BYTES && candidate.locations.length<=MAX_LOCS_HARD){
        cur.push(loc); curBytes=blen;
      } else {
        if (cur.length) batches.push({ locations: cur.slice(), bytes: curBytes });
        cur = [loc]; curBytes = byteLen({ type:'elev.query', dataset, locations: cur });
      }
    }
    if (cur.length) batches.push({ locations: cur.slice(), bytes: curBytes });
    return batches;
  }
  function indicesToBatchesGeohash(dataset, indices, toGeohash, meta){
    const batches = [];
    let cur = [], curBytes = 0;
    for (const idx of indices){
      const gh = toGeohash(idx);
      const candidate = { type:'elev.query', dataset, geohashes: cur.concat([gh]), ...meta };
      const blen = byteLen(candidate);
      if (blen<=DM_BUDGET_BYTES && candidate.geohashes.length<=MAX_LOCS_HARD){
        cur.push(gh); curBytes=blen;
      } else {
        if (cur.length) batches.push({ geohashes: cur.slice(), bytes: curBytes, meta });
        cur = [gh]; curBytes = byteLen({ type:'elev.query', dataset, geohashes: cur, ...meta });
      }
    }
    if (cur.length) batches.push({ geohashes: cur.slice(), bytes: curBytes, meta });
    return batches;
  }

  // ---------- Rebuild (i,j) from parsed LL with per-row scaling ----------
  function reconstructPtsFromParsed(parsed, center){
    const { lat:lat0, lng:lng0 } = center;
    const phi0 = lat0 * Math.PI/180;
    const mDegLatC = metersPerDegLat(phi0);
    const d  = Math.max(1, parseFloat(spacingEl.value||'50'));
    const ry = Math.sqrt(3)/2 * d;

    return parsed.map(p=>{
      const yM = (p.lat - lat0) * mDegLatC;
      let i = Math.round(yM / ry);

      const rowLat = lat0 + (i*ry) / mDegLatC;
      const mDegLonRow = metersPerDegLon(rowLat * Math.PI/180);

      const xOffset = (i & 1) ? 0.5*d : 0.0;
      const xM = (p.lng - lng0) * mDegLonRow;
      let j = Math.round((xM - xOffset) / d);

      const xq = j*d + xOffset, yq = i*ry;
      return { i, j, x:xq, y:yq, lat:p.lat, lng:p.lng };
    });
  }

  // ---------- Texture overlay (tile cutout ‚Üí UV-aligned map) ----------
  async function buildAndApplyTexture(){
    if (!mesh || !geom || !hexLayer || !lastHex) { log('‚ÑπÔ∏è texture: need hex + mesh first'); return; }
    const latlngs = (hexLayer.getLatLngs()[0] || []).map(ll=>({lat:ll.lat, lng:ll.lng}));
    if (latlngs.length !== 6){ log('‚ö†Ô∏è hex latlngs not found'); return; }

    const spacingM = Math.max(1, parseFloat(spacingEl.value||'50'));
    const targetMpp = Math.max(0.5, spacingM/2);
    const centerLat = lastHex.center.lat;
    const MAX_DIM = 3072; // pixels cap
    const z = pickZoomForTarget(centerLat, targetMpp, MAX_DIM, latlngs);
    currentZoom = z;

    // Project hex verts to pixel coords (z)
    let minx=Infinity,maxx=-Infinity,miny=Infinity,maxy=-Infinity;
    const hexPx = latlngs.map(ll=>{
      const x = lon2x(ll.lng, z), y = lat2y(ll.lat, z);
      if (x<minx) minx=x; if (x>maxx) maxx=x;
      if (y<miny) miny=y; if (y>maxy) maxy=y;
      return {x,y};
    });
    const W = Math.min(MAX_DIM, Math.ceil(maxx-minx));
    const H = Math.min(MAX_DIM, Math.ceil(maxy-miny));
    if (W<=2 || H<=2) { log('‚ö†Ô∏è texture bbox too small'); return; }

    // Collect tiles intersecting bbox
    const x0 = Math.floor(minx / TILE), x1 = Math.floor((maxx-1) / TILE);
    const y0 = Math.floor(miny / TILE), y1 = Math.floor((maxy-1) / TILE);
    const sub = 'a'; // choose subdomain
    const tpl = tileTemplateEl.value.trim();
    const toURL = (x,y)=> tpl
      .replace('{s}', sub)
      .replace('{x}', String(x))
      .replace('{y}', String(y))
      .replace('{z}', String(z));

    // Compose canvas clipped to hex
    const canvas = document.createElement('canvas');
    canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;

    // Hex clip path
    ctx.save();
    ctx.beginPath();
    for (let i=0;i<hexPx.length;i++){
      const p = hexPx[i];
      const lx = Math.round(p.x - minx), ly = Math.round(p.y - miny);
      if (i===0) ctx.moveTo(lx, ly); else ctx.lineTo(lx, ly);
    }
    ctx.closePath();
    ctx.clip();

    // Draw tiles
    const promises = [];
    for (let ty=y0; ty<=y1; ty++){
      for (let tx=x0; tx<=x1; tx++){
        const url = toURL(tx,ty);
        const img = new Image();
        img.crossOrigin = 'anonymous';
        const p = new Promise((resolve)=>{
          img.onload = ()=>{
            const dx = tx*TILE - minx;
            const dy = ty*TILE - miny;
            ctx.drawImage(img, Math.round(dx), Math.round(dy), TILE, TILE);
            resolve();
          };
          img.onerror = ()=>{ resolve(); };
        });
        img.src = url;
        promises.push(p);
      }
    }
    await Promise.all(promises);
    ctx.restore();

    // Build UVs from same projection
    const uv = new Float32Array(pts.length*2);
    for (let k=0;k<pts.length;k++){
      const px = lon2x(pts[k].lng, z);
      const py = lat2y(pts[k].lat, z);
      const u = (px - minx) / W;
      const v = 1 - (py - miny) / H;
      uv[k*2+0] = u;
      uv[k*2+1] = v;
    }
    geom.setAttribute('uv', new THREE.BufferAttribute(uv, 2));

    // Create Three texture
    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = Math.min(16, renderer.capabilities.getMaxAnisotropy?.() || 4);
    tex.minFilter = THREE.LinearMipmapLinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.generateMipmaps = true;
    tex.needsUpdate = true;

    // Apply
    if (mesh && mesh.material){
      mesh.material.map = tex;
      mesh.material.vertexColors = false;
      mesh.material.needsUpdate = true;
      currentTexture = tex;
      texInfoEl.textContent = `Texture: z${z} ‚Ä¢ ${W}√ó${H}px ‚Ä¢ mpp‚âà${groundResMpp(centerLat,z).toFixed(2)} ‚Ä¢ tiles ${(x1-x0+1)}√ó${(y1-y0+1)}`;
      log('üñºÔ∏è texture applied', { z, size:`${W}x${H}`, tiles:`${(x1-x0+1)}x${(y1-y0+1)}` });
    }
  }

  function removeTexture(){
    if (mesh && mesh.material){
      mesh.material.map = null;
      mesh.material.vertexColors = true;
      mesh.material.needsUpdate = true;
      texInfoEl.textContent = '';
    }
    if (currentTexture){ currentTexture.dispose?.(); currentTexture=null; }
  }

  // ---------- Wire up main ----------
  let mc;
  async function main(){
    initMap();
    useMyLocation();
    requireSDK();
    initThree();

    drawBtn.addEventListener('click', startDrawHexagon);

    map.on(L.Draw.Event.CREATED, (e)=>{
      const layer = e.layer;
      if (hexLayer) map.removeLayer(hexLayer);
      hexLayer = layer.addTo(map);

      const center = layer._hexCenter || layer.getBounds().getCenter();
      const apothemM = layer._apothemM || (function(){
        const latlngs = layer.getLatLngs()[0] || [];
        if (!latlngs.length) return 100;
        const Rm = map.distance(center, latlngs[0]);
        return Rm * Math.sqrt(3)/2;
      })();

      lastHex = { center: { lat: center.lat, lng: center.lng }, apothemM };
      log(`‚¨¢ Hex finalized. Center=(${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}), apothem ‚âà ${apothemM.toFixed(1)} m`);
      generateHexGrid(lastHex);
    });

    regenBtn.addEventListener('click', ()=>{ if (lastHex) { generateHexGrid(lastHex); if (overlayOn) buildAndApplyTexture(); } else log('‚ÑπÔ∏è draw a hexagon first'); });
    locBtn.addEventListener('click', useMyLocation);

    // Texture toggle
    textureToggleBtn.addEventListener('click', async ()=>{
      if (!mesh){ log('‚ÑπÔ∏è build mesh first (draw hex + regenerate + query optional)'); overlayOn = !overlayOn; textureToggleBtn.textContent = overlayOn ? 'üñºÔ∏è Overlay map texture: On' : 'üñºÔ∏è Overlay map texture: Off'; return; }
      overlayOn = !overlayOn;
      textureToggleBtn.textContent = overlayOn ? 'üñºÔ∏è Overlay map texture: On' : 'üñºÔ∏è Overlay map texture: Off';
      if (overlayOn){
        try { await buildAndApplyTexture(); }
        catch(e){ log('‚ùå texture build error:', e?.message||e); overlayOn=false; textureToggleBtn.textContent='üñºÔ∏è Overlay map texture: Off'; }
      } else {
        removeTexture();
      }
    });

    mc = new nkn.MultiClient({ numSubClients: 4, originalClient: false });
    myAddrEl.textContent = '‚Ä¶';
    setConn('connecting‚Ä¶', false);

    mc.onConnect(()=>{
      myAddrEl.textContent = mc.addr;
      setConn('connected', true);
      log('‚úÖ NKN connected as', mc.addr);
    });
    mc.onMessage(({ src, payload }) => handleIncoming(src, payload));

    pointsBox.addEventListener('input', ()=>{
      countPointsBox();
    });

    document.addEventListener('keydown', (e)=>{ if (e.key==='Enter' && (e.metaKey||e.ctrlKey)) queryBtn.click(); });

    queryBtn.addEventListener('click', async ()=>{
      const dest = (relayEl.value || '').trim();
      const dataset = (datasetEl.value || 'mapzen').trim();
      const zEx = parseFloat(zScaleEl.value || '1.0');
      if (!dest) return log('‚ö†Ô∏è enter relay address');

      const toks = splitTokens(pointsBox.value);
      const parsed = [];
      for (const tok of toks){
        const m = tok.match(/^\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*$/);
        if (!m) continue;
        parsed.push({lat: parseFloat(m[1]), lng: parseFloat(m[2])});
      }
      if (!parsed.length) { log('‚ö†Ô∏è no points found ‚Äî draw a hex and/or regenerate'); return; }
      if (!lastHex) { log('‚ö†Ô∏è draw a hex first'); return; }

      const latticePts = reconstructPtsFromParsed(parsed, lastHex.center);

      // maps for replies
      idxByLL = new Map();
      for (let k=0;k<latticePts.length;k++){
        idxByLL.set(`${latticePts[k].lat.toFixed(6)},${latticePts[k].lng.toFixed(6)}`, k);
      }

      // mesh
      buildHexMesh(latticePts);

      // progressive schedule
      const levels = buildProgressiveIndexLevelsTri(latticePts);
      levelInfoEl.textContent = `Levels: ${levels.map((L,i)=>`L${i+1}:${L.length}`).join(' | ')}`;

      const spacingM   = Math.max(1, parseFloat(spacingEl.value||'50'));
      const ghPrec     = pickGeohashPrecision(spacingM);
      const toLatLng   = (k)=> ({ lat: latticePts[k].lat, lng: latticePts[k].lng });
      const toGeohash  = (k)=> geohashEncode(latticePts[k].lat, latticePts[k].lng, ghPrec);

      idxByGH = null;
      if (SEND_MODE==='geohash'){
        idxByGH = new Map();
        for (let k=0;k<latticePts.length;k++) idxByGH.set(geohashEncode(latticePts[k].lat, latticePts[k].lng, ghPrec), k);
        log(`üß≠ geohash mode: precision ${ghPrec} (spacing‚âà${spacingM}m)`);
      }

      function applyResults(results, isGH){
        let any=false;
        for (const r of results){
          let k = undefined;
          if (isGH && r.geohash && idxByGH)          k = idxByGH.get(r.geohash);
          else if (r.location){
            const key = `${(+r.location.lat).toFixed(6)},${(+r.location.lng).toFixed(6)}`;
            k = idxByLL.get(key);
          }
          if (k===undefined) continue;
          const y = ((r.elevation ?? 0)*1.0) * zEx;
          elevs[k] = y;
          isFinal[k] = true;
          posAttr.array[k*3+1] = y;
          updateVertexColor(k, y);
          any=true;
        }
        if (any){ posAttr.needsUpdate = true; colorAttr.needsUpdate = true; }
      }

      let levelNo=0, totalFetched=0, totalPts=latticePts.length;
      for (const levelIndices of levels){
        levelNo++;

        let batches, modeLabel;
        if (SEND_MODE==='geohash'){
          const meta = { enc:'geohash', prec: ghPrec };
          batches = indicesToBatchesGeohash(dataset, levelIndices, toGeohash, meta);
          modeLabel = `geohash@${ghPrec}`;
        } else {
          batches = indicesToBatchesLatLng(dataset, levelIndices, toLatLng);
          modeLabel = 'lat/lng';
        }

        progressEl.textContent = `Level ${levelNo}/${levels.length} ‚Äî ${batches.length} batches (${modeLabel})`;
        let bi=0;

        for (const b of batches){
          bi++;
          const env = (SEND_MODE==='geohash')
            ? { type:'elev.query', dataset, geohashes: b.geohashes, ...b.meta }
            : { type:'elev.query', dataset, locations: b.locations };

          const t0 = performance.now();
          const resp = await sendWithReply(mc, dest, env, 60000)
            .catch(e=>{ log('‚ùå batch send error:', e?.message||e); return null; });
          const dt = Math.round(performance.now()-t0);
          if (!resp){ log(`‚ùå L${levelNo} batch ${bi} failed`); continue; }

          let json=null;
          if (resp.body_b64) { try { json = JSON.parse(atob(resp.body_b64)); } catch(e){ log(`‚ùì L${levelNo} batch ${bi} bad JSON`, e); continue; } }
          else if (resp.body) { json = (typeof resp.body === 'string') ? JSON.parse(resp.body) : resp.body; }
          if (!json || !Array.isArray(json.results)) { log(`‚ùì L${levelNo} batch ${bi} unexpected`, json); continue; }

          applyResults(json.results, SEND_MODE==='geohash');
          totalFetched += json.results.length;

          nearestAnchorFill();
          smoothUnknowns(2);

          progressEl.textContent = `Level ${levelNo}/${levels.length} ‚Äî batch ${bi}/${batches.length} (${totalFetched}/${totalPts}) ‚Äî ${dt} ms`;
          log(`üß© L${levelNo} batch ${bi}/${batches.length} applied (${json.results.length} pts)`);
          geom.computeVertexNormals();
        }
      }

      progressEl.textContent = `Done. Samples: ${isFinal.filter(Boolean).length}/${latticePts.length}`;
      geom.computeVertexNormals();
      log('‚úÖ progressive refine complete');

      if (overlayOn) buildAndApplyTexture();
    });
  }

  // ---------- Boot ----------
  window.addEventListener('load', () => {
    try { main(); } 
    catch (e) { log('‚ùå init error:', e.message || e); }
  });
})();
</script>
</body>
</html>
