<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NKN Tritree Globe â€” Orbit & Surface Modes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- NKN SDK UMD (global `nkn`) with fallback -->
  <script src="https://cdn.jsdelivr.net/gh/nknorg/nkn-sdk-js/dist/nkn.min.js"
          onerror="(function(){var s=document.createElement('script');s.src='https://nkn.org/nkn.min.js';document.head.appendChild(s);}())"></script>

  <!-- Three.js via import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
    }
  }
  </script>

  <style>
    :root {
      --bg: #020617;
      --panel: #020617cc;
      --accent: #22d3ee;
      --accent-soft: #38bdf8;
      --accent-strong: #06b6d4;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --ok: #4ade80;
      --bad: #f97373;
      --border: #1f2937;
    }
    *{box-sizing:border-box;}
    html,body{
      margin:0;
      padding:0;
      width:100%;
      height:100%;
      overflow:hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #0f172a 0, #020617 55%);
      color: var(--text);
    }
    #app{
      position:fixed;
      inset:0;
      display:flex;
      flex-direction:column;
    }
    #toolbar{
      padding:10px 14px;
      display:flex;
      flex-wrap:wrap;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      pointer-events:auto;
      background:linear-gradient(to bottom,
        rgba(15,23,42,0.95),
        rgba(15,23,42,0.75),
        rgba(15,23,42,0));
      z-index:10;
    }
    #toolbar-left{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    #title{
      font-size:14px;
      font-weight:600;
      letter-spacing:0.02em;
      white-space:nowrap;
    }
    #hint{
      font-size:12px;
      color:var(--muted);
    }
    .pill{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#02061799;
      font-size:11px;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .pill span.key{
      padding:1px 6px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617;
      font-size:10px;
      color:var(--accent-soft);
      font-weight:500;
    }
    #toolbar-right{
      display:flex;
      flex-wrap:wrap;
      align-items:flex-start;
      gap:10px;
      font-size:11px;
    }
    .field-group{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:160px;
    }
    .field-group label{
      font-size:11px;
      color:var(--muted);
    }
    .field-group input{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#02061799;
      color:var(--text);
      outline:none;
      font-size:11px;
      min-width:0;
    }
    .field-group input:focus{
      border-color:var(--accent-soft);
      box-shadow:0 0 0 1px rgba(56,189,248,0.35);
    }
    #myAddr{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px dashed var(--border);
      min-width:140px;
      white-space:nowrap;
    }
    #sdkStatus, #connStatus{
      font-size:11px;
    }
    #sdkStatus .ok, #connStatus .ok{color:var(--ok);}
    #sdkStatus .bad, #connStatus .bad{color:var(--bad);}

    .button-row{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }
    .mode-btn{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#02061799;
      color:var(--muted);
      font-size:11px;
      cursor:pointer;
      white-space:nowrap;
    }
    .mode-btn.small{
      padding:3px 7px;
      font-size:10px;
    }
    .mode-btn.active{
      border-color:var(--accent-soft);
      color:var(--accent-soft);
      background:#0b1120;
    }
    .mode-btn:focus-visible{
      outline:2px solid var(--accent-soft);
      outline-offset:1px;
    }

    #three-container{
      flex:1;
      position:relative;
    }
    #three-container canvas{
      display:block;
    }
    #metrics{
      position:absolute;
      right:10px;
      bottom:10px;
      padding:6px 10px;
      border-radius:12px;
      background:var(--panel);
      border:1px solid #1e293b;
      font-size:11px;
      color:var(--muted);
      pointer-events:none;
      backdrop-filter:blur(10px);
      min-width:190px;
    }
    #metrics strong{
      color:var(--accent-soft);
      font-weight:500;
    }
    #metrics .value{
      color:var(--text);
    }
  </style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <div id="toolbar-left">
      <div id="title">NKN Tritree Globe Â· Orbit & Surface Modes</div>
      <div id="hint">
        <span class="pill">
          <span class="key">Drag</span> orbit
          <span class="key">Wheel</span> zoom
          <span class="key">Shift + Click</span> drop to surface & walk
        </span>
      </div>
    </div>
    <div id="toolbar-right">
      <div class="field-group">
        <label for="relay">Forwarder address</label>
        <input id="relay" type="text" placeholder="forwarder.â€¦ or pubkey" />
      </div>
      <div class="field-group">
        <label for="dataset">Dataset</label>
        <input id="dataset" type="text" value="mapzen" />
      </div>
      <div class="field-group">
        <label>LOD mode</label>
        <div class="button-row">
          <button id="btnLodOrbit" class="mode-btn small active">Orbit</button>
          <button id="btnLodZoom" class="mode-btn small">Zoom focus</button>
        </div>
      </div>
      <div class="field-group">
        <label>Camera</label>
        <div class="button-row">
          <button id="btnCamOrbit" class="mode-btn small active">Orbit</button>
          <button id="btnCamSurface" class="mode-btn small">Surface</button>
        </div>
      </div>
      <div class="field-group">
        <label>My NKN address</label>
        <div id="myAddr">â€”</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:2px;min-width:160px;">
        <div id="sdkStatus">Loading nkn-sdkâ€¦</div>
        <div id="connStatus">Not connected</div>
      </div>
    </div>
  </div>
  <div id="three-container">
    <div id="metrics">
      <div><strong>Tiles</strong> <span class="value" id="metric-tiles">â€“</span></div>
      <div><strong>Max level</strong> <span class="value" id="metric-level">â€“</span></div>
      <div><strong>Hex selector</strong> <span class="value" id="metric-hex">none</span></div>
      <div><strong>Elev batches</strong> <span class="value" id="metric-batches">0</span></div>
      <div><strong>Vertices cached</strong> <span class="value" id="metric-verts">0</span></div>
    </div>
  </div>
</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Constants & helpers
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const PLANET_RADIUS = 1.0;
  const EARTH_RADIUS_M = 6_371_000;
  const ELEVATION_EXAGGERATION = 10.0; // exaggerate vertical relief
  const MAX_TILE_LEVEL = 5;

  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  const DEFAULT_FORWARDER =
    'forwarder.5d7bdb47e1c757508d28f5726469afa1f7c93bd037a1940aa0dab97ab421c833';

  const tilesPendingNormals = new Set();

  function dirToLatLon(dir) {
    // y = up, z = north, x = east
    const y = THREE.MathUtils.clamp(dir.y, -1, 1);
    const lat = Math.asin(y);
    const lon = Math.atan2(dir.x, dir.z);
    return {
      latDeg: THREE.MathUtils.radToDeg(lat),
      lonDeg: THREE.MathUtils.radToDeg(lon)
    };
  }

  function raySphereIntersection(origin, dir, radius = PLANET_RADIUS) {
    const o = origin.clone();
    const d = dir.clone().normalize();
    const b = o.dot(d);
    const c = o.lengthSq() - radius * radius;
    const disc = b * b - c;
    if (disc < 0) return null;
    let t = -b - Math.sqrt(disc);
    if (t < 0) t = -b + Math.sqrt(disc);
    if (t < 0) return null;
    return o.add(d.multiplyScalar(t));
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // NKN plumbing (sendWithReply + reply matching)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const pending = new Map();
  let lastPayloadBytes = 0;

  function uuidv4(){
    if (crypto.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
      const r = Math.random()*16|0, v = c==='x'?r:(r&0x3|0x8); return v.toString(16);
    });
  }

  function sendWithReply(mc, dest, obj, timeoutMs = 25000) {
    const id = obj.id || uuidv4();
    obj.id = id;
    const encoded = new TextEncoder().encode(JSON.stringify(obj));
    lastPayloadBytes = encoded.length;

    const p = new Promise((resolve, reject) => {
      const t = setTimeout(() => {
        pending.delete(id);
        reject(new Error('DM reply timeout'));
      }, timeoutMs);
      pending.set(id, { resolve, timeout: t });
    });

    mc.send(dest, JSON.stringify(obj)).catch(err => {
      const st = pending.get(id);
      if (st){ clearTimeout(st.timeout); pending.delete(id); }
      console.error('NKN send error:', err && err.message || err);
    });

    return p;
  }

  function handleIncoming(src, payload) {
    const text = (typeof payload === 'string')
      ? payload
      : new TextDecoder().decode(payload);
    let msg;
    try {
      msg = JSON.parse(text);
    } catch {
      console.log('ðŸ“¥ incoming (raw):', text);
      return;
    }
    if (msg && msg.type === 'http.response' && msg.id && pending.has(msg.id)) {
      const st = pending.get(msg.id);
      clearTimeout(st.timeout);
      pending.delete(msg.id);
      st.resolve(msg);
      return;
    }
    console.log('ðŸ“¥ unsolicited from', src, msg);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Elevation client (vertexâ€‘first, radial priority from camera)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  class ElevationClient {
    constructor() {
      this.mc = null;
      this.relayDest = '';
      this.dataset = 'mapzen';

      this.vertexMap = new Map(); // key -> record
      this.cameraPos = new THREE.Vector3();

      this.maxConcurrentBatches = 2;
      this.currentBatches = 0;
      this.batchSize = 80;
      this.minIntervalMs = 250;
      this.lastScheduleTime = 0;
    }

    setMultiClient(mc) {
      this.mc = mc;
    }

    setRelayAndDataset(relay, dataset) {
      this.relayDest = (relay || '').trim();
      this.dataset = (dataset || 'mapzen').trim();
    }

    registerVertex(latDeg, lonDeg, dir, tile, index) {
      const key = `${latDeg.toFixed(6)},${lonDeg.toFixed(6)}`;
      let rec = this.vertexMap.get(key);
      if (!rec) {
        rec = {
          key,
          lat: latDeg,
          lng: lonDeg,
          dir,
          clients: [],
          status: 'new',
          distance: Infinity,
          height: 0
        };
        this.vertexMap.set(key, rec);
      }
      rec.clients.push({ tile, index });
    }

    updateCamera(camera) {
      this.cameraPos.copy(camera.position);
    }

    tick() {
      if (!this.mc || !this.relayDest) return;
      if (this.currentBatches >= this.maxConcurrentBatches) return;

      const now = performance.now();
      if (now - this.lastScheduleTime < this.minIntervalMs) return;
      this.lastScheduleTime = now;

      const cameraPos = this.cameraPos;
      const candidates = [];

      for (const rec of this.vertexMap.values()) {
        if (rec.status === 'new') {
          const worldPos = rec.dir.clone().multiplyScalar(PLANET_RADIUS);
          rec.distance = worldPos.distanceTo(cameraPos);
          candidates.push(rec);
        }
      }

      if (!candidates.length) return;

      candidates.sort((a, b) => a.distance - b.distance);
      const batch = candidates.slice(0, this.batchSize);
      for (const rec of batch) {
        rec.status = 'pending';
      }

      const locations = batch.map(r => ({
        lat: r.lat,
        lng: r.lng
      }));

      const payload = {
        type: 'elev.query',
        dataset: this.dataset,
        locations
      };

      const thisBatch = batch;
      this.currentBatches++;

      sendWithReply(this.mc, this.relayDest, payload, 45000)
        .then(resp => {
          let json = null;
          try {
            if (resp.body_b64) {
              const decoded = atob(resp.body_b64);
              json = JSON.parse(decoded);
            } else if (resp.body) {
              json = typeof resp.body === 'string' ? JSON.parse(resp.body) : resp.body;
            }
          } catch (e) {
            console.error('[elev] bad JSON', e);
          }

          if (!json || !Array.isArray(json.results)) {
            console.warn('[elev] unexpected response format', json);
            for (const rec of thisBatch) {
              if (rec.status === 'pending') rec.status = 'error';
            }
            return;
          }

          for (const r of json.results) {
            if (!r.location) continue;
            const key = `${(+r.location.lat).toFixed(6)},${(+r.location.lng).toFixed(6)}`;
            const rec = this.vertexMap.get(key);
            if (!rec) continue;

            const elev = Number.isFinite(r.elevation) ? Number(r.elevation) : 0;
            rec.height = elev;
            rec.status = 'done';

            for (const ref of rec.clients) {
              ref.tile.updateVertex(ref.index, elev);
            }
          }

          for (const rec of thisBatch) {
            if (rec.status === 'pending') {
              rec.status = 'error';
            }
          }
        })
        .catch(err => {
          console.error('[elev] batch failed', err);
          for (const rec of thisBatch) {
            if (rec.status === 'pending') rec.status = 'error';
          }
        })
        .finally(() => {
          this.currentBatches--;
        });
    }

    getStats() {
      return {
        totalVertices: this.vertexMap.size,
        currentBatches: this.currentBatches
      };
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Triangular tile (spherical tritree node)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  class TriTile {
    constructor(v0, v1, v2, level = 0, index = 0, parent = null, radius = PLANET_RADIUS, elevationClient = null) {
      this.v0 = v0.clone().normalize();
      this.v1 = v1.clone().normalize();
      this.v2 = v2.clone().normalize();
      this.level = level;
      this.index = index;
      this.parent = parent;
      this.radius = radius;
      this.elevationClient = elevationClient;

      this.children = null;
      this.geometry = null;
      this.mesh = null;
      this.baseDirs = null;
      this.positionAttr = null;

      this.centerDir = new THREE.Vector3()
        .add(this.v0)
        .add(this.v1)
        .add(this.v2)
        .normalize();
      this.center = this.centerDir.clone().multiplyScalar(this.radius);

      const a0 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v0), -1, 1));
      const a1 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v1), -1, 1));
      const a2 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v2), -1, 1));
      this.angularRadius = Math.max(a0, a1, a2);
    }

    subdivide() {
      if (this.children) return this.children;

      const mid01 = new THREE.Vector3().addVectors(this.v0, this.v1).normalize();
      const mid12 = new THREE.Vector3().addVectors(this.v1, this.v2).normalize();
      const mid20 = new THREE.Vector3().addVectors(this.v2, this.v0).normalize();

      const childLevel = this.level + 1;
      this.children = [
        new TriTile(mid01, mid12, mid20, childLevel, this.index * 4,     this, this.radius, this.elevationClient),
        new TriTile(this.v0, mid01, mid20, childLevel, this.index * 4+1, this, this.radius, this.elevationClient),
        new TriTile(this.v1, mid12, mid01, childLevel, this.index * 4+2, this, this.radius, this.elevationClient),
        new TriTile(this.v2, mid20, mid12, childLevel, this.index * 4+3, this, this.radius, this.elevationClient),
      ];
      return this.children;
    }

    buildGeometry() {
      if (this.geometry) return this.geometry;

      const baseRes = 6;
      const resPerLevel = 2;
      const res = Math.min(baseRes + this.level * resPerLevel, 22);

      const vertices = [];
      const dirs = [];
      const indices = [];

      const v0 = this.v0;
      const v1 = this.v1;
      const v2 = this.v2;

      let idx = 0;
      for (let i = 0; i <= res; i++) {
        for (let j = 0; j <= res - i; j++) {
          const k = res - i - j;
          const w0 = i / res;
          const w1 = j / res;
          const w2 = k / res;

          let px = w0 * v0.x + w1 * v1.x + w2 * v2.x;
          let py = w0 * v0.y + w1 * v1.y + w2 * v2.y;
          let pz = w0 * v0.z + w1 * v1.z + w2 * v2.z;

          const len = Math.sqrt(px*px + py*py + pz*pz) || 1;
          px /= len; py /= len; pz /= len;

          const dir = new THREE.Vector3(px, py, pz);

          const r = this.radius;
          vertices.push(dir.x * r, dir.y * r, dir.z * r);
          dirs.push(dir.x, dir.y, dir.z);

          if (this.elevationClient) {
            const { latDeg, lonDeg } = dirToLatLon(dir);
            this.elevationClient.registerVertex(latDeg, lonDeg, dir.clone(), this, idx);
          }

          idx++;
        }
      }

      let vIdx = 0;
      for (let i = 0; i < res; i++) {
        const rowStart = vIdx;
        const rowLen = res - i + 1;
        const nextRowStart = vIdx + rowLen;

        for (let j = 0; j < res - i; j++) {
          const a = rowStart + j;
          const b = rowStart + j + 1;
          const c = nextRowStart + j;

          indices.push(a, b, c);

          if (j < res - i - 1) {
            const d = nextRowStart + j + 1;
            indices.push(b, d, c);
          }
        }

        vIdx = nextRowStart;
      }

      const positionArray = new Float32Array(vertices);
      const baseDirArray = new Float32Array(dirs);
      const indexArray = new Uint32Array(indices);

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      geom.setIndex(new THREE.BufferAttribute(indexArray, 1));
      geom.computeVertexNormals();
      geom.attributes.position.setUsage(THREE.DynamicDrawUsage);

      this.geometry = geom;
      this.baseDirs = baseDirArray;
      this.positionAttr = geom.getAttribute('position');

      return geom;
    }

    ensureMesh(parent, material) {
      if (!this.mesh) {
        this.buildGeometry();
        this.mesh = new THREE.Mesh(this.geometry, material);
        this.mesh.castShadow = false;
        this.mesh.receiveShadow = false;
        parent.add(this.mesh);
      }
    }

    setVisible(visible) {
      if (this.mesh) this.mesh.visible = visible;
    }

    hideDescendants() {
      if (!this.children) return;
      for (const child of this.children) {
        child.setVisible(false);
        child.hideDescendants();
      }
    }

    updateVertex(index, elevMeters) {
      if (!this.positionAttr || !this.baseDirs) return;
      const base = this.baseDirs;
      const pos = this.positionAttr.array;

      const bx = base[index*3 + 0];
      const by = base[index*3 + 1];
      const bz = base[index*3 + 2];

      const rel = (elevMeters * ELEVATION_EXAGGERATION) / EARTH_RADIUS_M;
      const r = this.radius * (1 + rel);

      pos[index*3 + 0] = bx * r;
      pos[index*3 + 1] = by * r;
      pos[index*3 + 2] = bz * r;

      this.positionAttr.needsUpdate = true;
      tilesPendingNormals.add(this);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Icosahedron â†’ root tiles
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function createIcosahedronTiles(radius, elevationClient) {
    const t = (1 + Math.sqrt(5)) / 2;
    const verts = [
      new THREE.Vector3(-1,  t,  0).normalize(),
      new THREE.Vector3( 1,  t,  0).normalize(),
      new THREE.Vector3(-1, -t,  0).normalize(),
      new THREE.Vector3( 1, -t,  0).normalize(),

      new THREE.Vector3( 0, -1,  t).normalize(),
      new THREE.Vector3( 0,  1,  t).normalize(),
      new THREE.Vector3( 0, -1, -t).normalize(),
      new THREE.Vector3( 0,  1, -t).normalize(),

      new THREE.Vector3( t,  0, -1).normalize(),
      new THREE.Vector3( t,  0,  1).normalize(),
      new THREE.Vector3(-t,  0, -1).normalize(),
      new THREE.Vector3(-t,  0,  1).normalize(),
    ];

    const faces = [
      [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
      [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
      [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
      [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1],
    ];

    const tiles = [];
    for (let i = 0; i < faces.length; i++) {
      const [i0, i1, i2] = faces[i];
      tiles.push(
        new TriTile(verts[i0], verts[i1], verts[i2], 0, i, null, radius, elevationClient)
      );
    }
    return tiles;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Tritree manager (LOD + hex patch)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  class TriTreeManager {
    constructor(scene, elevationClient, radius = PLANET_RADIUS) {
      this.scene = scene;
      this.radius = radius;
      this.elevationClient = elevationClient;

      this.group = new THREE.Group();
      this.group.name = 'PlanetGroup';
      this.scene.add(this.group);

      this.rootTiles = createIcosahedronTiles(radius, elevationClient);
      this.material = new THREE.MeshStandardMaterial({
        color: 0x4b5563,
        metalness: 0.0,
        roughness: 0.95,
        flatShading: false,
        side: THREE.DoubleSide, // requested: patches visible from both sides
      });

      this.visibleTileCount = 0;
      this.currentMaxLevel = 0;
      this.hexPatch = null; // { centerDir, radius }
      this.lodMode = 'orbit'; // 'orbit' or 'zoom'
      this.viewFocusDir = null;

      for (const tile of this.rootTiles) {
        tile.ensureMesh(this.group, this.material);
        tile.setVisible(true);
      }
    }

    setHexPatch(centerDir, radius) {
      if (!centerDir || !Number.isFinite(radius) || radius <= 0) {
        this.hexPatch = null;
      } else {
        this.hexPatch = {
          centerDir: centerDir.clone().normalize(),
          radius
        };
      }
    }

    setLODMode(mode) {
      this.lodMode = (mode === 'zoom') ? 'zoom' : 'orbit';
    }

    _desiredLevelForTile(tile, camera) {
      const camPos = camera.position.clone();
      const dist = camPos.length();

      let baseLevel = 0;

      if (this.lodMode === 'orbit') {
        // Terrain where we "orbit to" â€” bias around sub-solar point of camera
        const surfaceDir = camPos.normalize();
        const dotCam = THREE.MathUtils.clamp(tile.centerDir.dot(surfaceDir), -1, 1);
        const angleToCam = Math.acos(dotCam);
        const angleDeg = angleToCam * RAD2DEG;

        let levelFromCam;
        if (angleDeg > 85) levelFromCam = 0;
        else if (angleDeg > 65) levelFromCam = 1;
        else if (angleDeg > 45) levelFromCam = 2;
        else if (angleDeg > 25) levelFromCam = 3;
        else if (angleDeg > 12) levelFromCam = 4;
        else levelFromCam = 5;

        baseLevel = levelFromCam;
      } else {
        // Zoom-focus LOD: only aggressively refine the area under the crosshair.
        const focusDir = this.viewFocusDir || camPos.clone().normalize();
        const dotF = THREE.MathUtils.clamp(tile.centerDir.dot(focusDir), -1, 1);
        const angleToFocus = Math.acos(dotF);
        const angleDeg = angleToFocus * RAD2DEG;

        let levelFromFocus;
        if (angleDeg > 60) levelFromFocus = 0;
        else if (angleDeg > 40) levelFromFocus = 1;
        else if (angleDeg > 25) levelFromFocus = 2;
        else if (angleDeg > 15) levelFromFocus = 3;
        else if (angleDeg > 8) levelFromFocus = 4;
        else levelFromFocus = 5;

        baseLevel = levelFromFocus;
      }

      // Distance from planet surface also matters: closer â†’ more detail.
      if (dist < 2.0) baseLevel += 2;
      else if (dist < 2.8) baseLevel += 1;

      let levelFromPatch = 0;
      const patch = this.hexPatch;
      if (patch && patch.centerDir) {
        const dotP = THREE.MathUtils.clamp(tile.centerDir.dot(patch.centerDir), -1, 1);
        const angleToPatch = Math.acos(dotP);

        if (angleToPatch - tile.angularRadius <= patch.radius * 1.1) {
          if (angleToPatch < patch.radius * 0.3) levelFromPatch = MAX_TILE_LEVEL;
          else if (angleToPatch < patch.radius * 0.6) levelFromPatch = Math.max(4, MAX_TILE_LEVEL - 1);
          else levelFromPatch = 3;
        }
      }

      let desired = Math.max(baseLevel, levelFromPatch);
      desired = Math.max(0, Math.min(MAX_TILE_LEVEL, desired));
      return desired;
    }

    _shouldSplitTile(tile, camera) {
      if (tile.level >= MAX_TILE_LEVEL) return false;
      const desired = this._desiredLevelForTile(tile, camera);
      return tile.level < desired;
    }

    _updateTileLOD(tile, camera) {
      const split = this._shouldSplitTile(tile, camera);

      if (split) {
        tile.subdivide();
        tile.setVisible(false);
        if (tile.children) {
          for (const child of tile.children) {
            child.ensureMesh(this.group, this.material);
            child.setVisible(true);
            this.visibleTileCount++;
            this.currentMaxLevel = Math.max(this.currentMaxLevel, child.level);
            this._updateTileLOD(child, camera);
          }
        }
      } else {
        tile.ensureMesh(this.group, this.material);
        tile.setVisible(true);
        this.visibleTileCount++;
        this.currentMaxLevel = Math.max(this.currentMaxLevel, tile.level);
        if (tile.children) {
          for (const child of tile.children) {
            child.setVisible(false);
            child.hideDescendants();
          }
        }
      }
    }

    update(camera) {
      // Compute focus direction from camera for zoom LOD
      const viewDir = new THREE.Vector3();
      camera.getWorldDirection(viewDir);
      const hit = raySphereIntersection(camera.position, viewDir);
      this.viewFocusDir = hit ? hit.clone().normalize() : camera.position.clone().normalize();

      this.visibleTileCount = 0;
      this.currentMaxLevel = 0;
      for (const root of this.rootTiles) {
        this._updateTileLOD(root, camera);
      }
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Globals for scene / camera / modes
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  let triTree = null;

  const terrainRaycaster = new THREE.Raycaster();
  const clickRaycaster = new THREE.Raycaster();
  const clickNDC = new THREE.Vector2();

  let cameraMode = 'orbit'; // 'orbit' | 'surface'
  let lodMode = 'orbit';    // 'orbit' | 'zoom'

  const keys = new Set();

  let surfacePos = null;      // ground point on terrain
  const surfaceUp = new THREE.Vector3();
  const surfaceForward = new THREE.Vector3();
  const surfaceRight = new THREE.Vector3();
  const surfaceBaseForward = new THREE.Vector3();
  let surfaceYaw = 0;
  let surfacePitch = 0;
  const MAX_PITCH = 80 * DEG2RAD;
  const EYE_HEIGHT = 0.01 * PLANET_RADIUS; // eye above terrain
  const SURFACE_SPEED = 0.25; // units per second

  let isPointerDraggingSurface = false;
  let lastPointerX = 0;
  let lastPointerY = 0;

  const orbitSavedPosition = new THREE.Vector3();
  const orbitSavedTarget = new THREE.Vector3();

  function isEditableTarget(el) {
    if (!el) return false;
    const tag = (el.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
    if (el.isContentEditable) return true;
    if (el.getAttribute && el.getAttribute('contenteditable') === 'true') return true;
    return false;
  }

  function getTerrainPointFromDir(dir) {
    if (!triTree || !triTree.group) {
      return dir.clone().normalize().multiplyScalar(PLANET_RADIUS);
    }
    const origin = dir.clone().normalize().multiplyScalar(PLANET_RADIUS * 2.0);
    const rayDir = dir.clone().normalize().multiplyScalar(-1);
    terrainRaycaster.set(origin, rayDir);
    const hits = terrainRaycaster.intersectObject(triTree.group, true);
    if (hits.length > 0) {
      return hits[0].point.clone();
    }
    return dir.clone().normalize().multiplyScalar(PLANET_RADIUS);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Main scene setup
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  window.addEventListener('load', () => {
    const container = document.getElementById('three-container');
    const metricTiles = document.getElementById('metric-tiles');
    const metricLevel = document.getElementById('metric-level');
    const metricHex = document.getElementById('metric-hex');
    const metricBatches = document.getElementById('metric-batches');
    const metricVerts = document.getElementById('metric-verts');

    const relayEl = document.getElementById('relay');
    const datasetEl = document.getElementById('dataset');
    const myAddrEl = document.getElementById('myAddr');
    const sdkStatusEl = document.getElementById('sdkStatus');
    const connStatusEl = document.getElementById('connStatus');

    const btnLodOrbit = document.getElementById('btnLodOrbit');
    const btnLodZoom = document.getElementById('btnLodZoom');
    const btnCamOrbit = document.getElementById('btnCamOrbit');
    const btnCamSurface = document.getElementById('btnCamSurface');

    const LS_RELAY = 'nkn.globe.relay';
    const LS_DATASET = 'nkn.globe.dataset';

    relayEl.value = localStorage.getItem(LS_RELAY) || DEFAULT_FORWARDER;
    datasetEl.value = localStorage.getItem(LS_DATASET) || 'mapzen';

    function setSDKStatus(ok, text) {
      if (ok) {
        sdkStatusEl.innerHTML = '<span class="ok">' + (text || 'nkn-sdk loaded') + '</span>';
      } else {
        sdkStatusEl.innerHTML = '<span class="bad">' + (text || 'nkn-sdk not loaded') + '</span>';
      }
    }

    function setConnStatus(ok, text) {
      if (ok) {
        connStatusEl.innerHTML = '<span class="ok">' + (text || 'connected') + '</span>';
      } else {
        connStatusEl.innerHTML = '<span class="bad">' + (text || 'not connected') + '</span>';
      }
    }

    // Renderer / scene / camera
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#020617');

    const camera = new THREE.PerspectiveCamera(
      45,
      container.clientWidth / container.clientHeight,
      0.1,
      50
    );
    camera.position.set(0, 0, 3.5);
    camera.lookAt(0, 0, 0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 1.2;
    controls.maxDistance = 6.0;
    controls.target.set(0, 0, 0);

    orbitSavedPosition.copy(camera.position);
    orbitSavedTarget.copy(controls.target);

    const hemi = new THREE.HemisphereLight(0x93c5fd, 0x020617, 0.7);
    scene.add(hemi);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(3, 4, 2);
    scene.add(dirLight);

    const elevationClient = new ElevationClient();
    triTree = new TriTreeManager(scene, elevationClient, PLANET_RADIUS);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Small hex selector (repurposed)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    const hexGeometry = new THREE.BufferGeometry();
    const hexMaterial = new THREE.LineBasicMaterial({ color: 0x22d3ee });
    const hexLine = new THREE.LineLoop(hexGeometry, hexMaterial);
    hexLine.visible = false;
    scene.add(hexLine);

    const hexSelection = {
      centerDir: null,
      radius: 5 * DEG2RAD
    };

    function updateHexVisualization() {
      const patch = hexSelection;
      if (!patch.centerDir) {
        hexLine.visible = false;
        metricHex.textContent = 'none';
        triTree.setHexPatch(null, 0);
        return;
      }

      const segments = 6;
      const positions = new Float32Array((segments + 1) * 3);
      const c = patch.centerDir.clone().normalize();
      const r = patch.radius;

      let up = new THREE.Vector3(0, 1, 0);
      if (Math.abs(up.dot(c)) > 0.98) {
        up = new THREE.Vector3(1, 0, 0);
      }
      const east = new THREE.Vector3().crossVectors(up, c).normalize();
      const north = new THREE.Vector3().crossVectors(c, east).normalize();

      for (let k = 0; k < segments; k++) {
        const phi = (Math.PI / 3) * k;
        const tangent = new THREE.Vector3()
          .copy(east).multiplyScalar(Math.cos(phi))
          .add(new THREE.Vector3().copy(north).multiplyScalar(Math.sin(phi)));

        const dir = new THREE.Vector3()
          .copy(c).multiplyScalar(Math.cos(r))
          .add(tangent.multiplyScalar(Math.sin(r)))
          .normalize();

        const i3 = k * 3;
        const scale = PLANET_RADIUS * 1.001;
        positions[i3 + 0] = dir.x * scale;
        positions[i3 + 1] = dir.y * scale;
        positions[i3 + 2] = dir.z * scale;

        if (k === 0) {
          const j3 = segments * 3;
          positions[j3 + 0] = positions[i3 + 0];
          positions[j3 + 1] = positions[i3 + 1];
          positions[j3 + 2] = positions[i3 + 2];
        }
      }

      hexGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      hexGeometry.computeBoundingSphere();
      hexLine.visible = true;

      metricHex.textContent = (patch.radius / DEG2RAD).toFixed(1) + 'Â°';
      triTree.setHexPatch(patch.centerDir, patch.radius);
    }

    function setHexSelection(dir) {
      hexSelection.centerDir = dir.clone().normalize();
      hexSelection.radius = 5 * DEG2RAD;
      updateHexVisualization();
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Orbit â†” Surface camera switching
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function updateCameraButtons() {
      btnCamOrbit.classList.toggle('active', cameraMode === 'orbit');
      btnCamSurface.classList.toggle('active', cameraMode === 'surface');
    }

    function switchToOrbit() {
      if (cameraMode === 'orbit') return;
      cameraMode = 'orbit';
      controls.enabled = true;

      camera.position.copy(orbitSavedPosition);
      controls.target.copy(orbitSavedTarget);
      controls.update();

      updateCameraButtons();
      renderer.domElement.style.cursor = '';
    }

    function updateSurfaceCamera() {
      if (cameraMode !== 'surface' || !surfacePos) return;

      const up = surfaceUp.clone().normalize();
      let forward = surfaceBaseForward.clone();

      // Orthonormal basis
      forward.sub(up.clone().multiplyScalar(forward.dot(up))).normalize();
      let right = new THREE.Vector3().crossVectors(forward, up).normalize();
      forward = new THREE.Vector3().crossVectors(up, right).normalize();

      const yawQuat = new THREE.Quaternion().setFromAxisAngle(up, surfaceYaw);
      forward.applyQuaternion(yawQuat);
      right.crossVectors(forward, up).normalize();

      const pitchQuat = new THREE.Quaternion().setFromAxisAngle(right, surfacePitch);
      forward.applyQuaternion(pitchQuat);
      forward.normalize();
      right.crossVectors(forward, up).normalize();

      surfaceForward.copy(forward);
      surfaceRight.copy(right);

      const eyeHeight = EYE_HEIGHT;
      camera.position.copy(surfacePos.clone().add(up.clone().multiplyScalar(eyeHeight)));
      camera.up.copy(up);
      const lookTarget = surfacePos.clone().add(forward);
      camera.lookAt(lookTarget);
    }

    function goToSurfaceAtDirection(dir) {
      const ground = getTerrainPointFromDir(dir);
      const up = ground.clone().normalize();

      // Save orbit state before switching
      orbitSavedPosition.copy(camera.position);
      orbitSavedTarget.copy(controls.target);

      surfacePos = ground.clone();
      surfaceUp.copy(up);

      // Base forward: world north projected onto tangent plane
      const worldNorth = new THREE.Vector3(0, 0, 1);
      let baseFwd = worldNorth.clone().sub(up.clone().multiplyScalar(worldNorth.dot(up)));
      if (baseFwd.lengthSq() < 1e-6) {
        baseFwd.set(1, 0, 0);
      }
      baseFwd.normalize();
      surfaceBaseForward.copy(baseFwd);

      surfaceYaw = 0;
      surfacePitch = 0;

      cameraMode = 'surface';
      controls.enabled = false;
      updateCameraButtons();
      renderer.domElement.style.cursor = '';

      updateSurfaceCamera();
    }

    // Surface movement
    function updateSurfaceMovement(dt) {
      if (cameraMode !== 'surface' || !surfacePos) return;

      const move = new THREE.Vector3();
      if (keys.has('KeyW') || keys.has('ArrowUp')) move.add(surfaceForward);
      if (keys.has('KeyS') || keys.has('ArrowDown')) move.addScaledVector(surfaceForward, -1);
      if (keys.has('KeyA') || keys.has('ArrowLeft')) move.addScaledVector(surfaceRight, -1);
      if (keys.has('KeyD') || keys.has('ArrowRight')) move.add(surfaceRight);

      if (move.lengthSq() === 0) return;

      move.normalize();
      const sprint = keys.has('ShiftLeft') || keys.has('ShiftRight');
      const speed = SURFACE_SPEED * (sprint ? 2.0 : 1.0);
      move.multiplyScalar(speed * dt);

      const newPos = surfacePos.clone().add(move);
      const newDir = newPos.clone().normalize();
      const ground = getTerrainPointFromDir(newDir);
      surfacePos.copy(ground);
      surfaceUp.copy(surfacePos.clone().normalize());

      updateSurfaceCamera();
    }

    // Camera buttons: orbit â†” surface
    btnCamOrbit.addEventListener('click', () => {
      switchToOrbit();
    });

    btnCamSurface.addEventListener('click', () => {
      // Drop to surface at the current view focus
      const viewDir = new THREE.Vector3();
      camera.getWorldDirection(viewDir);
      const hit = raySphereIntersection(camera.position, viewDir);
      if (hit) {
        const dir = hit.clone().normalize();
        setHexSelection(dir);
        goToSurfaceAtDirection(dir);
      }
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Pointer & keyboard input
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function getSphereIntersectionFromEvent(e) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      clickNDC.set(x, y);

      clickRaycaster.setFromCamera(clickNDC, camera);
      return raySphereIntersection(clickRaycaster.ray.origin, clickRaycaster.ray.direction);
    }

    function onPointerDown(e) {
      if (e.button !== 0) return;

      if (cameraMode === 'orbit') {
        if (e.shiftKey) {
          const hit = getSphereIntersectionFromEvent(e);
          if (hit) {
            e.preventDefault();
            const dir = hit.clone().normalize();
            setHexSelection(dir);
            goToSurfaceAtDirection(dir);
          }
        }
      } else if (cameraMode === 'surface') {
        if (!isEditableTarget(e.target)) {
          isPointerDraggingSurface = true;
          lastPointerX = e.clientX;
          lastPointerY = e.clientY;
          renderer.domElement.style.cursor = 'grabbing';
        }
      }
    }

    function onPointerMove(e) {
      if (cameraMode === 'surface' && isPointerDraggingSurface) {
        const dx = e.clientX - lastPointerX;
        const dy = e.clientY - lastPointerY;
        lastPointerX = e.clientX;
        lastPointerY = e.clientY;

        const yawSpeed = 0.0025;
        const pitchSpeed = 0.0025;
        surfaceYaw -= dx * yawSpeed;
        surfacePitch -= dy * pitchSpeed;
        surfacePitch = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, surfacePitch));

        updateSurfaceCamera();
      }
    }

    function onPointerUp() {
      if (cameraMode === 'surface') {
        isPointerDraggingSurface = false;
        renderer.domElement.style.cursor = '';
      }
    }

    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp);

    window.addEventListener('keydown', (e) => {
      if (isEditableTarget(e.target)) return;
      keys.add(e.code);
      if (e.code === 'Escape' && cameraMode === 'surface') {
        switchToOrbit();
      }
    });

    window.addEventListener('keyup', (e) => {
      keys.delete(e.code);
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Resize
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function onResize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    window.addEventListener('resize', onResize);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // NKN init + relay/dataset binding
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let mc = null;

    function initNKN() {
      if (!window.nkn || !nkn.MultiClient) {
        setSDKStatus(false, 'nkn-sdk not loaded (check CDN)');
        return;
      }
      setSDKStatus(true, 'nkn-sdk loaded');
      try {
        mc = new nkn.MultiClient({ numSubClients: 4, originalClient: false });
      } catch (e) {
        setConnStatus(false, 'failed to create MultiClient');
        console.error('NKN init error', e);
        return;
      }

      myAddrEl.textContent = 'â€¦';
      setConnStatus(false, 'connectingâ€¦');

      mc.onConnect(() => {
        myAddrEl.textContent = mc.addr;
        setConnStatus(true, 'connected');
        elevationClient.setMultiClient(mc);
        console.log('âœ… NKN connected as', mc.addr);
      });

      mc.onMessage(({ src, payload }) => handleIncoming(src, payload));
    }

    initNKN();

    function updateRelayDataset() {
      const relay = (relayEl.value.trim() || DEFAULT_FORWARDER);
      const dataset = datasetEl.value.trim() || 'mapzen';
      relayEl.value = relay;
      localStorage.setItem(LS_RELAY, relay);
      localStorage.setItem(LS_DATASET, dataset);
      elevationClient.setRelayAndDataset(relay, dataset);
    }

    relayEl.addEventListener('input', updateRelayDataset);
    relayEl.addEventListener('change', updateRelayDataset);
    datasetEl.addEventListener('input', updateRelayDataset);
    datasetEl.addEventListener('change', updateRelayDataset);
    updateRelayDataset();

    // LOD mode toggle
    function updateLodButtons() {
      btnLodOrbit.classList.toggle('active', lodMode === 'orbit');
      btnLodZoom.classList.toggle('active', lodMode === 'zoom');
    }

    btnLodOrbit.addEventListener('click', () => {
      lodMode = 'orbit';
      triTree.setLODMode('orbit');
      updateLodButtons();
    });
    btnLodZoom.addEventListener('click', () => {
      lodMode = 'zoom';
      triTree.setLODMode('zoom');
      updateLodButtons();
    });

    updateLodButtons();
    updateCameraButtons();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Animation loop
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let lastTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      if (cameraMode === 'orbit') {
        controls.update();
      } else {
        updateSurfaceMovement(dt);
      }

      triTree.update(camera);
      elevationClient.updateCamera(camera);
      elevationClient.tick();

      if (tilesPendingNormals.size) {
        tilesPendingNormals.forEach(tile => {
          if (tile.geometry) tile.geometry.computeVertexNormals();
        });
        tilesPendingNormals.clear();
      }

      const stats = elevationClient.getStats();
      metricTiles.textContent = triTree.visibleTileCount.toString();
      metricLevel.textContent = triTree.currentMaxLevel.toString();
      metricBatches.textContent = stats.currentBatches.toString();
      metricVerts.textContent = stats.totalVertices.toString();

      renderer.render(scene, camera);
    }

    animate();
  });
</script>
</body>
</html>
