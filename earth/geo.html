<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NKN Tritree Globe ¬∑ Orbit + Wayback Imagery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- NKN SDK UMD (global `nkn`) with fallback -->
  <script src="https://cdn.jsdelivr.net/gh/nknorg/nkn-sdk-js/dist/nkn.min.js"
          onerror="(function(){var s=document.createElement('script');s.src='https://nkn.org/nkn.min.js';document.head.appendChild(s);}())"></script>

  <!-- Three.js via import map (TSL/WebGPU included in main module) -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>

  <style>
    :root {
      --bg: #020617;
      --panel: #020617d9;
      --panel-solid: #020617f2;
      --accent: #22d3ee;
      --accent-soft: #38bdf8;
      --accent-strong: #06b6d4;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --ok: #4ade80;
      --bad: #f97373;
      --border: #1f2937;
      --border-strong: #111827;
      --chip-bg: #02061799;
    }
    * { box-sizing: border-box; }
    html, body {
      margin:0;
      padding:0;
      width:100%;
      height:100%;
      overflow:hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #020617 55%);
      color: var(--text);
    }
    #app {
      position:fixed;
      inset:0;
      display:flex;
      flex-direction:column;
    }

    /* Top toolbar */
    #toolbar {
      padding:10px 14px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      pointer-events:auto;
      background:linear-gradient(to bottom,
        rgba(15,23,42,0.96),
        rgba(15,23,42,0.78),
        rgba(15,23,42,0));
      border-bottom:1px solid #0f172a;
      z-index:10;
    }
    #toolbar-left {
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    #title {
      font-size:14px;
      font-weight:600;
      letter-spacing:0.06em;
      text-transform:uppercase;
    }
    #subtitle {
      font-size:11px;
      color:var(--muted);
      letter-spacing:0.02em;
    }
    #hint {
      font-size:11px;
      color:var(--muted);
      margin-top:2px;
    }
    .pill {
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--chip-bg);
      font-size:11px;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .pill span.key {
      padding:1px 6px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617;
      font-size:10px;
      color:var(--accent-soft);
      font-weight:500;
    }

    #three-container {
      flex:1;
      position:relative;
    }
    #three-container canvas {
      display:block;
    }

    /* Debug bug bottom-left */
    #debug-toggle{
      position:absolute;
      left:10px;
      bottom:10px;
      width:26px;
      height:26px;
      border-radius:50%;
      border:1px solid var(--border);
      background:#020617dd;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:15px;
      cursor:pointer;
      color:var(--muted);
      z-index:20;
      box-shadow:0 0 0 1px #020617, 0 8px 20px rgba(0,0,0,0.55);
    }
    #debug-toggle.active{
      border-color:var(--accent-soft);
      color:var(--accent-soft);
      background:#020617;
    }
    #debug-panel{
      position:absolute;
      left:10px;
      bottom:44px;
      width:260px;
      max-height:220px;
      overflow:auto;
      border-radius:12px;
      padding:8px 10px;
      background:var(--panel);
      border:1px solid #1e293b;
      font-size:11px;
      color:var(--muted);
      backdrop-filter:blur(10px);
      z-index:20;
      display:none;
    }
    #debug-panel.open{
      display:block;
    }
    #debug-panel h4{
      margin:0 0 4px 0;
      font-size:11px;
      font-weight:600;
      color:var(--accent-soft);
      letter-spacing:0.06em;
      text-transform:uppercase;
    }
    #debug-panel .fps{
      margin-bottom:4px;
      font-size:11px;
      color:var(--text);
    }
    .perf-row{
      margin-bottom:4px;
    }
    .perf-row-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:6px;
    }
    .perf-name{
      font-weight:500;
      color:var(--accent-soft);
    }
    .perf-numbers{
      font-size:10px;
      white-space:nowrap;
    }
    .perf-bar{
      margin-top:2px;
      width:100%;
      height:5px;
      border-radius:999px;
      background:#0b112033;
      overflow:hidden;
    }
    .perf-bar span{
      display:block;
      height:100%;
      border-radius:999px;
      background:linear-gradient(90deg, var(--accent-soft), var(--accent-strong));
      transform-origin:left center;
    }

    /* Sidebar toggle (right Edge) */
    #sidebar-toggle {
      position:absolute;
      top:50%;
      right:10px;
      transform:translateY(-50%);
      width:30px;
      height:30px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617dd;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
      cursor:pointer;
      color:var(--muted);
      z-index:25;
      box-shadow:0 0 0 1px #020617, 0 8px 20px rgba(0,0,0,0.55);
    }
    #sidebar-toggle.open {
      border-color:var(--accent-soft);
      color:var(--accent-soft);
      background:#020617;
    }

    /* Sidebar */
    #sidebar {
      position:absolute;
      top:0;
      right:0;
      bottom:0;
      width:300px;
      max-width:82%;
      background:var(--panel-solid);
      border-left:1px solid var(--border-strong);
      box-shadow:-18px 0 40px rgba(0,0,0,0.85);
      transform:translateX(100%);
      transition:transform 0.22s cubic-bezier(0.24, 0.8, 0.3, 1);
      z-index:24;
      display:flex;
      flex-direction:column;
      backdrop-filter:blur(16px);
    }
    #sidebar.open {
      transform:translateX(0);
    }
    #sidebar-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px 8px 14px;
      border-bottom:1px solid var(--border);
    }
    #sidebar-title {
      font-size:12px;
      font-weight:600;
      letter-spacing:0.12em;
      text-transform:uppercase;
      color:var(--muted);
    }
    #sidebar-close {
      border:none;
      outline:none;
      background:transparent;
      color:var(--muted);
      cursor:pointer;
      font-size:18px;
      line-height:1;
      padding:0 4px;
    }
    #sidebar-tabs {
      display:flex;
      padding:6px 8px;
      gap:4px;
      border-bottom:1px solid var(--border);
    }
    .sidebar-tab {
      flex:1;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617dd;
      color:var(--muted);
      font-size:11px;
      padding:4px 6px;
      cursor:pointer;
      text-align:center;
      white-space:nowrap;
    }
    .sidebar-tab.active {
      border-color:var(--accent-soft);
      color:var(--accent-soft);
      background:#0b1120;
    }
    #sidebar-pages {
      flex:1;
      overflow:auto;
      padding:8px 11px 10px 11px;
      font-size:11px;
    }
    .sidebar-page {
      display:none;
    }
    .sidebar-page.active {
      display:block;
    }

    .sidebar-section {
      margin-bottom:10px;
      padding:7px 8px 9px 8px;
      border-radius:10px;
      background:radial-gradient(circle at top left, #0b112022, transparent 55%);
      border:1px solid #0b1120;
    }
    .sidebar-section + .sidebar-section {
      margin-top:6px;
    }
    .sidebar-section-title {
      font-size:11px;
      font-weight:600;
      color:var(--accent-soft);
      margin-bottom:4px;
      text-transform:uppercase;
      letter-spacing:0.06em;
    }
    .sidebar-section-subtitle {
      font-size:10px;
      color:var(--muted);
      margin-bottom:4px;
    }

    .field-group {
      display:flex;
      flex-direction:column;
      gap:3px;
      margin-bottom:6px;
    }
    .field-group label {
      font-size:11px;
      color:var(--muted);
    }
    .field-group input {
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#02061799;
      color:var(--text);
      outline:none;
      font-size:11px;
      min-width:0;
    }
    .field-group input:focus{
      border-color:var(--accent-soft);
      box-shadow:0 0 0 1px rgba(56,189,248,0.35);
    }
    .field-row-inline {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:6px;
    }
    .field-row-inline input {
      max-width:80px;
      text-align:right;
    }
    .field-note {
      font-size:10px;
      color:var(--muted);
      margin-top:2px;
    }

    .metric-list {
      display:flex;
      flex-direction:column;
      gap:2px;
      margin-top:2px;
    }
    .metric-row {
      display:flex;
      justify-content:space-between;
      gap:8px;
    }
    .metric-label {
      color:var(--muted);
    }
    .metric-value {
      color:var(--text);
      font-variant-numeric:tabular-nums;
    }

    .pill-small {
      display:inline-flex;
      align-items:center;
      gap:6px;
      border-radius:999px;
      border:1px solid var(--border);
      padding:3px 7px;
      background:#020617aa;
      font-size:10px;
      margin-top:4px;
    }
    .pill-small span.key {
      padding:1px 5px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617;
      font-size:9px;
      color:var(--accent-soft);
      font-weight:500;
    }

    .mode-btn-small {
      padding:3px 7px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617dd;
      color:var(--muted);
      font-size:10px;
      cursor:pointer;
      white-space:nowrap;
      margin-right:4px;
      margin-top:2px;
    }
    .mode-btn-small.active {
      border-color:var(--accent-soft);
      color:var(--accent-soft);
      background:#0b1120;
    }

    #myAddr {
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px dashed var(--border);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    #imageryPreview {
      width:100%;
      max-width:220px;
      border-radius:10px;
      border:1px solid #111827;
      background:#000;
      image-rendering:pixelated;
      display:block;
    }
    #imageryUrl {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:10px;
      color:#9ca3af;
      word-break:break-all;
      margin-top:4px;
    }
    .btn-inline {
      padding:3px 7px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#020617dd;
      color:var(--muted);
      font-size:10px;
      cursor:pointer;
      white-space:nowrap;
    }
    .btn-inline.primary {
      border-color:var(--accent-soft);
      color:var(--accent-soft);
    }
    .chip-toggle {
      display:flex;
      align-items:center;
      gap:6px;
      margin-top:4px;
      font-size:10px;
      color:var(--muted);
    }
    .chip-toggle input {
      accent-color:var(--accent-soft);
    }
  </style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <div id="toolbar-left">
      <div id="title">NKN Tritree Globe</div>
      <div id="subtitle">Orbit ¬∑ Elevation via NKN ¬∑ Esri Wayback imagery mapped to spherical tritree tiles</div>
      <div id="hint">
        <span class="pill">
          <span class="key">Drag</span> orbit
          <span class="key">Wheel</span> zoom
          <span class="key">Shift + Click</span> focus hex patch
        </span>
      </div>
    </div>
  </div>

  <div id="three-container">
    <!-- Sidebar toggle & panel -->
    <button id="sidebar-toggle" title="Toggle configuration">‚öôÔ∏è</button>
    <div id="sidebar">
      <div id="sidebar-header">
        <div id="sidebar-title">Config ¬∑ Metrics</div>
        <button id="sidebar-close" aria-label="Close sidebar">√ó</button>
      </div>
      <div id="sidebar-tabs">
        <button class="sidebar-tab active" data-tab="overview">Overview</button>
        <button class="sidebar-tab" data-tab="lighting">Lighting / Time</button>
        <button class="sidebar-tab" data-tab="elevation">Elevation / NKN</button>
        <button class="sidebar-tab" data-tab="imagery">Imagery &amp; LOD</button>
      </div>
      <div id="sidebar-pages">
        <!-- Overview -->
        <div class="sidebar-page active" data-page="overview">
          <div class="sidebar-section">
            <div class="sidebar-section-title">Session</div>
            <div class="field-group">
              <label>nkn-sdk</label>
              <div id="sdkStatus">Loading nkn-sdk‚Ä¶</div>
            </div>
            <div class="field-group">
              <label>Connection</label>
              <div id="connStatus">Not connected</div>
            </div>
            <div class="field-group">
              <label>My NKN address</label>
              <div id="myAddr">‚Äî</div>
            </div>
          </div>

          <div class="sidebar-section">
            <div class="sidebar-section-title">Globe</div>
            <div class="metric-list">
              <div class="metric-row">
                <span class="metric-label">Visible tiles</span>
                <span class="metric-value" id="metric-tiles">‚Äì</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Max level</span>
                <span class="metric-value" id="metric-level">‚Äì</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Hex selector</span>
                <span class="metric-value" id="metric-hex">none</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Lat / Lon (center)</span>
                <span class="metric-value" id="metric-latlon">‚Äì</span>
              </div>
            </div>
          </div>

          <div class="sidebar-section">
            <div class="sidebar-section-title">Elevation traffic</div>
            <div class="metric-list">
              <div class="metric-row">
                <span class="metric-label">Active batches</span>
                <span class="metric-value" id="metric-batches">0</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Vertices cached</span>
                <span class="metric-value" id="metric-verts">0</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Requests</span>
                <span class="metric-value" id="metric-reqs">0</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Points out</span>
                <span class="metric-value" id="metric-points-out">0</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">KB out</span>
                <span class="metric-value" id="metric-kbout">0</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Responses</span>
                <span class="metric-value" id="metric-resps">0</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Points in</span>
                <span class="metric-value" id="metric-points-in">0</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">KB in</span>
                <span class="metric-value" id="metric-kbin">0</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">In / Out ratio</span>
                <span class="metric-value" id="metric-ratio">‚Äì</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Elevation / NKN -->
        <div class="sidebar-page" data-page="elevation">
          <div class="sidebar-section">
            <div class="sidebar-section-title">NKN forwarder</div>
            <div class="sidebar-section-subtitle">
              Forwarder that proxies elevation queries to your dataset.
            </div>
            <div class="field-group">
              <label for="relay">Forwarder address</label>
              <input id="relay" type="text" placeholder="forwarder.‚Ä¶ or pubkey" />
            </div>
            <div class="field-group">
              <label for="dataset">Dataset key</label>
              <input id="dataset" type="text" value="mapzen" />
            </div>
          </div>

          <div class="sidebar-section">
            <div class="sidebar-section-title">Elevation fetch tuning</div>
            <div class="field-group">
              <label>Batch size (points)</label>
              <div class="field-row-inline">
                <span>Vertices / batch</span>
                <input id="cfg-batchSize" type="number" min="1" max="500" step="1" value="80" />
              </div>
            </div>
            <div class="field-group">
              <label>Max concurrent batches</label>
              <div class="field-row-inline">
                <span>Concurrency</span>
                <input id="cfg-maxConcurrent" type="number" min="1" max="8" step="1" value="2" />
              </div>
            </div>
            <div class="field-group">
              <label>Min interval between batches</label>
              <div class="field-row-inline">
                <span>Interval (ms)</span>
                <input id="cfg-minInterval" type="number" min="50" max="2000" step="50" value="250" />
              </div>
            </div>
            <div class="field-group">
              <label>Max outbound traffic</label>
              <div class="field-row-inline">
                <span>KB / minute (0 = unlimited)</span>
                <input id="cfg-maxKBPerMin" type="number" min="0" max="65535" step="16" value="512" />
              </div>
            </div>
            <div class="field-note">
              Batches prioritize vertices inside the camera FOV, then fill nearby off-screen
              vertices for a quick coarse pass and refinement as you linger or zoom.
            </div>
          </div>
        </div>

        <!-- Lighting / Time -->
        <div class="sidebar-page" data-page="lighting">
          <div class="sidebar-section">
            <div class="sidebar-section-title">Sun Position & Time</div>
            <div class="sidebar-section-subtitle">
              Real-time astronomical sun position with Earth's 23.44¬∞ axial tilt.
            </div>

            <div class="field-group">
              <label>Current Date</label>
              <input id="cfg-date" type="date" />
            </div>

            <div class="field-group">
              <label>Time of Day (UTC)</label>
              <div class="field-row-inline">
                <input id="cfg-time" type="time" step="60" />
              </div>
            </div>

            <div class="field-group">
              <label>Time Speed</label>
              <div class="field-row-inline">
                <span id="cfg-timeSpeedLabel">Paused</span>
                <input id="cfg-timeSpeed" type="number" min="0" max="3600" step="1" value="0" />
              </div>
              <div class="field-note">
                Multiplier: 0=paused, 1=real-time, 60=1min/sec, 3600=1hr/sec
              </div>
            </div>

            <div style="margin-top:8px; display:flex; gap:4px; flex-wrap:wrap;">
              <button id="btn-timeNow" class="mode-btn-small active">Now</button>
              <button id="btn-timeSunrise" class="mode-btn-small">Sunrise</button>
              <button id="btn-timeNoon" class="mode-btn-small">Noon</button>
              <button id="btn-timeSunset" class="mode-btn-small">Sunset</button>
              <button id="btn-timeMidnight" class="mode-btn-small">Midnight</button>
            </div>

            <div class="chip-toggle" style="margin-top:8px;">
              <input id="cfg-useSimplified" type="checkbox" checked />
              <label for="cfg-useSimplified">Simplified mode (faster)</label>
            </div>

            <div class="field-note" style="margin-top:4px;">
              Simplified mode uses time-of-day only. Disable for full astronomical calculation with lat/lng.
            </div>
          </div>

          <div class="sidebar-section">
            <div class="sidebar-section-title">Atmosphere Settings</div>

            <div class="field-group">
              <label>Day Color</label>
              <input id="cfg-atmDayColor" type="color" value="#4db2ff" />
            </div>

            <div class="field-group">
              <label>Twilight Color</label>
              <input id="cfg-atmTwilightColor" type="color" value="#bc490b" />
            </div>

            <div class="chip-toggle" style="margin-top:8px;">
              <input id="cfg-atmosphereEnabled" type="checkbox" checked />
              <label for="cfg-atmosphereEnabled">Show atmosphere</label>
            </div>
          </div>

          <div class="sidebar-section">
            <div class="sidebar-section-title">Sun Info</div>
            <div class="metric-list">
              <div class="metric-row">
                <span class="metric-label">Current time</span>
                <span class="metric-value" id="metric-currentTime">‚Äì</span>
              </div>
              <div class="metric-row">
                <span class="metric-label">Sun direction</span>
                <span class="metric-value" id="metric-sunDir">‚Äì</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Imagery & LOD -->
        <div class="sidebar-page" data-page="imagery">
          <div class="sidebar-section">
            <div class="sidebar-section-title">Esri Wayback imagery</div>
            <div class="sidebar-section-subtitle">
              Imagery tiles are fetched per tritree tile, using WebMercator z/x/y like in your
              minimap ‚Üí WMTS setup.
            </div>
            <div class="chip-toggle">
              <input id="cfg-imageryEnabled" type="checkbox" checked />
              <label for="cfg-imageryEnabled">Enable imagery on globe</label>
            </div>
            <div class="field-group" style="margin-top:5px;">
              <label for="cfg-imageryVersion">Wayback version ID</label>
              <input id="cfg-imageryVersion" type="text" value="49849" />
            </div>
            <div class="field-group">
              <label for="cfg-imageryZoom">Imagery zoom (TileMatrix)</label>
              <div class="field-row-inline">
                <span>z (0‚Äì18)</span>
                <input id="cfg-imageryZoom" type="number" min="0" max="18" step="1" value="6" />
              </div>
            </div>

            <div class="field-row-inline" style="margin-top:4px;">
              <button id="btnImageryPreview" class="btn-inline primary">
                Preview tile under center
              </button>
              <span style="font-size:10px;color:var(--muted);">Uses center lat/lon + z ‚Üí x/y</span>
            </div>

            <div style="margin-top:6px;">
              <img id="imageryPreview" alt="WMTS tile preview" />
              <div id="imageryUrl"></div>
            </div>
          </div>

          <div class="sidebar-section">
            <div class="sidebar-section-title">LOD mode</div>
            <div>
              <button id="btnLodOrbit" class="mode-btn-small active">Orbit falloff</button>
              <button id="btnLodZoom" class="mode-btn-small">Zoom focus</button>
            </div>
            <div class="pill-small">
              <span class="key">Orbit</span> falloff from camera-facing point
              &nbsp;¬∑&nbsp;
              <span class="key">Zoom</span> FOV-based refinement
            </div>
          </div>

          <div class="sidebar-section">
            <div class="sidebar-section-title">Tile budgets</div>
            <div class="field-group">
              <label>Tile budget</label>
              <div class="field-row-inline">
                <span>Max tiles</span>
                <input id="cfg-tileBudget" type="number" min="200" max="8000" step="100" />
              </div>
            </div>
            <div class="field-group">
              <label>Per-frame split budget</label>
              <div class="field-row-inline">
                <span>Splits / frame</span>
                <input id="cfg-splitBudget" type="number" min="4" max="256" step="4" />
              </div>
            </div>
            <div class="field-group">
              <label>Per-frame merge budget</label>
              <div class="field-row-inline">
                <span>Merges / frame</span>
                <input id="cfg-mergeBudget" type="number" min="4" max="256" step="4" />
              </div>
            </div>
            <div class="field-note">
              Higher budgets refine faster but cost more CPU/GPU. Tile budget caps total
              active spherical triangle patches.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Debug toggle + panel -->
    <button id="debug-toggle" title="Toggle performance debug">üêû</button>
    <div id="debug-panel">
      <h4>Frame timings</h4>
      <div class="fps" id="debug-fps">FPS: ‚Äî</div>
      <div id="debug-content"></div>
    </div>
  </div>
</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // Import our custom modules
  import { LightingSystem } from './modules/lighting-system.js';
  import { createEarthMaterial, createAtmosphereMaterial } from './modules/earth-material.js';
  import { loadEarthTexturesWithFallback } from './modules/texture-loader.js';

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Constants & helpers (Earth scale, meters)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // Real-world astronomical constants (1 unit = 1 meter)
  const EARTH_RADIUS_M = 6_371_000; // 6,371 km
  const PLANET_RADIUS = EARTH_RADIUS_M;
  const SUN_RADIUS_M = 696_000_000; // 696,000 km
  const SUN_EARTH_DISTANCE_M = 149_597_870_700; // 1 AU = ~149.6 million km

  const CAMERA_NEAR = 1000;
  const CAMERA_FAR = SUN_EARTH_DISTANCE_M * 2; // Far enough to see the sun

  const ALT_30K_UNITS = 30_000;
  const ALT_10K_UNITS = 10_000;

  const ELEVATION_EXAGGERATION = 1.0;
  const MAX_TILE_LEVEL = 5;

  const DEG2RAD = Math.PI / 180;
  const RAD2DEG = 180 / Math.PI;

  const DEFAULT_FORWARDER =
    'forwarder.5d7bdb47e1c757508d28f5726469afa1f7c93bd037a1940aa0dab97ab421c833';

  const WMTS_ROOT =
    'https://wayback.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/WMTS/1.0.0/default028mm/MapServer';

  const tilesPendingNormals = new Set();
  let viewportHeight = window.innerHeight || 800;

  function dirToLatLon(dir) {
    const y = THREE.MathUtils.clamp(dir.y, -1, 1);
    const lat = Math.asin(y);
    const lon = Math.atan2(dir.x, dir.z);
    return {
      latDeg: THREE.MathUtils.radToDeg(lat),
      lonDeg: THREE.MathUtils.radToDeg(lon)
    };
  }

  function worldPosToLatLon(vec) {
    const r = vec.length();
    if (!r) return null;
    const yNorm = THREE.MathUtils.clamp(vec.y / r, -1, 1);
    const lat = Math.asin(yNorm);
    const lon = Math.atan2(vec.x, vec.z);
    return { latDeg: lat * RAD2DEG, lonDeg: lon * RAD2DEG };
  }

  function raySphereIntersection(origin, dir, radius = PLANET_RADIUS) {
    const o = origin.clone();
    const d = dir.clone().normalize();
    const b = o.dot(d);
    const c = o.lengthSq() - radius * radius;
    const disc = b * b - c;
    if (disc < 0) return null;
    let t = -b - Math.sqrt(disc);
    if (t < 0) t = -b + Math.sqrt(disc);
    if (t < 0) return null;
    return o.add(d.multiplyScalar(t));
  }

  // WebMercator tile math (extended) inspired by your minimap ‚Üí WMTS sample :contentReference[oaicite:2]{index=2}
  function lonLatToTileCoords(lonDeg, latDeg, z) {
    const latRad = latDeg * Math.PI / 180;
    const n = Math.pow(2, z);
    const cx = (lonDeg + 180) / 360 * n;
    const cy = (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n;
    const x = Math.floor(cx);
    const y = Math.floor(cy);
    return { x, y, cx, cy, n };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Perf instrumentation & debug UI
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  const perf = {
    sections: {},
    enabled: false,
    frameStart: 0,
    lastPanelUpdate: 0
  };

  function perfStart(name) {
    if (!perf.enabled) return;
    const s = perf.sections[name] || (perf.sections[name] = {
      total:0, samples:0, last:0, max:0, _start:0
    });
    s._start = performance.now();
  }
  function perfEnd(name) {
    if (!perf.enabled) return;
    const s = perf.sections[name];
    if (!s || s._start == null) return;
    const dt = performance.now() - s._start;
    s.last = dt;
    s.total += dt;
    s.samples++;
    if (dt > s.max) s.max = dt;
    s._start = null;
  }

  function updateDebugPanel() {
    if (!perf.enabled) return;
    const panel = document.getElementById('debug-panel');
    const content = document.getElementById('debug-content');
    const fpsEl = document.getElementById('debug-fps');
    if (!panel || !content || !fpsEl) return;

    const sFrame = perf.sections.frame;
    const frameAvg = sFrame && sFrame.samples ? (sFrame.total / sFrame.samples) : null;
    if (frameAvg) {
      const fps = 1000 / frameAvg;
      fpsEl.textContent = `FPS: ${fps.toFixed(1)} (frame ~${frameAvg.toFixed(1)} ms)`;
    } else {
      fpsEl.textContent = 'FPS: ‚Äî';
    }

    const entries = [];
    for (const [name, s] of Object.entries(perf.sections)) {
      if (name === 'frame') continue;
      if (!s.samples) continue;
      const avg = s.total / s.samples;
      entries.push({ name, avg, last: s.last, max: s.max });
    }
    entries.sort((a, b) => b.avg - a.avg);

    let html = '';
    for (const e of entries) {
      const pct = frameAvg ? Math.min(100, (e.avg / frameAvg) * 100) : 0;
      html += `
        <div class="perf-row">
          <div class="perf-row-header">
            <div class="perf-name">${e.name}</div>
            <div class="perf-numbers">
              ${e.avg.toFixed(2)} ms avg
              &nbsp;¬∑&nbsp;last ${e.last.toFixed(2)}
              &nbsp;¬∑&nbsp;max ${e.max.toFixed(2)}
            </div>
          </div>
          <div class="perf-bar"><span style="width:${pct.toFixed(1)}%"></span></div>
        </div>
      `;
    }
    content.innerHTML = html;
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // NKN plumbing (sendWithReply + reply matching)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  const pending = new Map();
  let lastPayloadBytes = 0;

  function uuidv4(){
    if (crypto.randomUUID) return crypto.randomUUID();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
      const r = Math.random()*16|0, v = c==='x'?r:(r&0x3|0x8); return v.toString(16);
    });
  }

  function sendWithReply(mc, dest, obj, timeoutMs = 25000, onBytes) {
    const id = obj.id || uuidv4();
    obj.id = id;
    const encoded = new TextEncoder().encode(JSON.stringify(obj));
    lastPayloadBytes = encoded.length;
    if (typeof onBytes === 'function') onBytes(lastPayloadBytes, obj);

    const p = new Promise((resolve, reject) => {
      const t = setTimeout(() => {
        pending.delete(id);
        reject(new Error('DM reply timeout'));
      }, timeoutMs);
      pending.set(id, { resolve, timeout: t });
    });

    mc.send(dest, JSON.stringify(obj)).catch(err => {
      const st = pending.get(id);
      if (st){ clearTimeout(st.timeout); pending.delete(id); }
      console.error('NKN send error:', err && err.message || err);
    });

    return p;
  }

  function handleIncoming(src, payload) {
    const text = (typeof payload === 'string')
      ? payload
      : new TextDecoder().decode(payload);
    let msg;
    try {
      msg = JSON.parse(text);
    } catch {
      console.log('üì• incoming (raw):', text);
      return;
    }
    if (msg && msg.type === 'http.response' && msg.id && pending.has(msg.id)) {
      const st = pending.get(msg.id);
      clearTimeout(st.timeout);
      pending.delete(msg.id);
      st.resolve(msg);
      return;
    }
    console.log('üì• unsolicited from', src, msg);
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Elevation client (FOV-aware, cached, metered)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  class ElevationClient {
    constructor() {
      this.mc = null;
      this.relayDest = '';
      this.dataset = 'mapzen';

      this.vertexMap = new Map();
      this.cameraPos = new THREE.Vector3();
      this.cameraDir = new THREE.Vector3(0, 0, -1);
      this.cameraFovRad = 45 * DEG2RAD;

      this.maxConcurrentBatches = 2;
      this.currentBatches = 0;
      this.batchSize = 80;
      this.minIntervalMs = 250;
      this.lastScheduleTime = 0;

      this.maxKBPerMinute = 512; // 0 = unlimited
      this.windowMs = 60_000;
      this.sendEvents = [];

      this.stats = {
        requestCount: 0,
        pointsRequested: 0,
        bytesOut: 0,
        responseCount: 0,
        pointsReceived: 0,
        bytesIn: 0
      };
    }

    setMultiClient(mc) {
      this.mc = mc;
    }

    setRelayAndDataset(relay, dataset) {
      this.relayDest = (relay || '').trim();
      this.dataset = (dataset || 'mapzen').trim();
    }

    setConfig({ batchSize, maxConcurrent, minIntervalMs, maxKBPerMinute }) {
      if (Number.isFinite(batchSize) && batchSize > 0) {
        this.batchSize = Math.max(1, Math.min(500, Math.floor(batchSize)));
      }
      if (Number.isFinite(maxConcurrent) && maxConcurrent > 0) {
        this.maxConcurrentBatches = Math.max(1, Math.min(8, Math.floor(maxConcurrent)));
      }
      if (Number.isFinite(minIntervalMs) && minIntervalMs > 0) {
        this.minIntervalMs = Math.max(50, Math.min(5000, Math.floor(minIntervalMs)));
      }
      if (Number.isFinite(maxKBPerMinute) && maxKBPerMinute >= 0) {
        this.maxKBPerMinute = Math.floor(maxKBPerMinute);
      }
    }

    _recordOutbound(bytes, count) {
      if (!Number.isFinite(bytes)) return;
      const now = performance.now();
      this.sendEvents.push({ t: now, bytes });
      const cutoff = now - this.windowMs;
      this.sendEvents = this.sendEvents.filter(ev => ev.t >= cutoff);

      this.stats.requestCount++;
      this.stats.pointsRequested += (count || 0);
      this.stats.bytesOut += bytes;
    }

    _recordInbound(bytes, count) {
      if (!Number.isFinite(bytes)) return;
      this.stats.responseCount++;
      this.stats.pointsReceived += (count || 0);
      this.stats.bytesIn += bytes;
    }

    _canSendBatch() {
      const capKB = this.maxKBPerMinute;
      if (!capKB || capKB <= 0) return true;
      const now = performance.now();
      const cutoff = now - this.windowMs;
      let totalBytes = 0;
      this.sendEvents = this.sendEvents.filter(ev => ev.t >= cutoff);
      for (const ev of this.sendEvents) totalBytes += ev.bytes;
      const totalKB = totalBytes / 1024;
      return totalKB < capKB;
    }

    registerVertex(latDeg, lonDeg, dir, tile, index) {
      const key = `${latDeg.toFixed(6)},${lonDeg.toFixed(6)}`;
      let rec = this.vertexMap.get(key);
      if (!rec) {
        rec = {
          key,
          lat: latDeg,
          lng: lonDeg,
          dir: dir.clone(),
          clients: [],
          status: 'new',
          distance: Infinity,
          height: 0
        };
        this.vertexMap.set(key, rec);
      }
      rec.clients.push({ tile, index });

      if (rec.status === 'done') {
        tile.updateVertex(index, rec.height);
      }
    }

    updateCamera(camera) {
      this.cameraPos.copy(camera.position);
      camera.getWorldDirection(this.cameraDir);
      this.cameraFovRad = camera.fov * DEG2RAD;
    }

    tick() {
      if (!this.mc || !this.relayDest) return;
      if (this.currentBatches >= this.maxConcurrentBatches) return;
      if (!this._canSendBatch()) return;

      const now = performance.now();
      if (now - this.lastScheduleTime < this.minIntervalMs) return;
      this.lastScheduleTime = now;

      const cameraPos = this.cameraPos;
      const viewDir = this.cameraDir;
      const maxAngle = this.cameraFovRad * 0.75;

      const inView = [];
      const offView = [];

      for (const rec of this.vertexMap.values()) {
        if (rec.status !== 'new') continue;

        const worldPos = rec.dir.clone().multiplyScalar(PLANET_RADIUS);
        rec.distance = worldPos.distanceTo(cameraPos);

        const dot = THREE.MathUtils.clamp(rec.dir.dot(viewDir), -1, 1);
        const angle = Math.acos(dot);

        if (angle < maxAngle) inView.push(rec);
        else offView.push(rec);
      }

      if (!inView.length && !offView.length) return;

      inView.sort((a, b) => a.distance - b.distance);
      offView.sort((a, b) => a.distance - b.distance);

      const batch = [];
      const totalBudget = this.batchSize;
      const inViewBudget = Math.floor(totalBudget * 0.7);

      batch.push(...inView.slice(0, inViewBudget));
      if (batch.length < totalBudget) {
        batch.push(...offView.slice(0, totalBudget - batch.length));
      }
      if (!batch.length) return;

      for (const rec of batch) {
        rec.status = 'pending';
      }

      const locations = batch.map(r => ({
        lat: r.lat,
        lng: r.lng
      }));

      const payload = {
        type: 'elev.query',
        dataset: this.dataset,
        locations
      };

      const thisBatch = batch;
      this.currentBatches++;

      sendWithReply(this.mc, this.relayDest, payload, 45000,
        (bytesOut) => this._recordOutbound(bytesOut, locations.length)
      ).then(resp => {
        let json = null;
        let bytesIn = 0;
        try {
          if (resp.body_b64) {
            bytesIn = resp.body_b64.length * 0.75;
            const decoded = atob(resp.body_b64);
            json = JSON.parse(decoded);
          } else if (resp.body) {
            const bodyStr = (typeof resp.body === 'string') ? resp.body : JSON.stringify(resp.body);
            bytesIn = bodyStr.length;
            json = typeof resp.body === 'string' ? JSON.parse(resp.body) : resp.body;
          }
        } catch (e) {
          console.error('[elev] bad JSON', e);
        }

        if (!json || !Array.isArray(json.results)) {
          console.warn('[elev] unexpected response format', json);
          for (const rec of thisBatch) {
            if (rec.status === 'pending') rec.status = 'error';
          }
          return;
        }

        this._recordInbound(bytesIn, json.results.length || 0);

        for (const r of json.results) {
          if (!r.location) continue;
          const key = `${(+r.location.lat).toFixed(6)},${(+r.location.lng).toFixed(6)}`;
          const rec = this.vertexMap.get(key);
          if (!rec) continue;

          const elev = Number.isFinite(r.elevation) ? Number(r.elevation) : 0;
          rec.height = elev;
          rec.status = 'done';

          for (const ref of rec.clients) {
            ref.tile.updateVertex(ref.index, elev);
          }
        }

        for (const rec of thisBatch) {
          if (rec.status === 'pending') rec.status = 'error';
        }
      })
      .catch(err => {
        console.error('[elev] batch failed', err);
        for (const rec of thisBatch) {
          if (rec.status === 'pending') rec.status = 'error';
        }
      })
      .finally(() => {
        this.currentBatches--;
      });
    }

    getStats() {
      return {
        totalVertices: this.vertexMap.size,
        currentBatches: this.currentBatches,
        ...this.stats
      };
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Imagery manager (Esri Wayback WMTS)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  class ImageryManager {
    constructor() {
      this.enabled = true;
      this.versionId = '49849';
      this.zoom = 6;

      this.loader = new THREE.TextureLoader();
      this.loader.crossOrigin = 'anonymous';
      this.cache = new Map(); // key: version|z|x|y -> {texture, promise}
    }

    setConfig({ enabled, versionId, zoom }) {
      if (typeof enabled === 'boolean') this.enabled = enabled;
      if (versionId) this.versionId = String(versionId).trim();
      if (Number.isFinite(zoom)) {
        this.zoom = Math.max(0, Math.min(18, Math.floor(zoom)));
      }
    }

    getConfig() {
      return {
        enabled: this.enabled,
        versionId: this.versionId,
        zoom: this.zoom
      };
    }

    buildUrl(versionId, z, x, y) {
      return `${WMTS_ROOT}/tile/${versionId}/${z}/${y}/${x}`;
    }

    getTile(x, y, z) {
      const versionId = this.versionId;
      const key = `${versionId}|${z}|${x}|${y}`;
      const cached = this.cache.get(key);
      if (cached) {
        if (cached.texture) return Promise.resolve(cached.texture);
        if (cached.promise) return cached.promise;
      }

      const url = this.buildUrl(versionId, z, x, y);
      const promise = new Promise((resolve) => {
        this.loader.load(
          url,
          tex => {
            tex.encoding = THREE.sRGBEncoding;
            tex.anisotropy = 4;
            this.cache.set(key, { texture: tex });
            resolve(tex);
          },
          undefined,
          err => {
            console.error('[imagery] failed to load', url, err);
            this.cache.set(key, { texture: null });
            resolve(null);
          }
        );
      });
      this.cache.set(key, { promise });
      return promise;
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Triangular tile (spherical tritree node)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  class TriTile {
    constructor(v0, v1, v2, level = 0, index = 0, parent = null,
                radius = PLANET_RADIUS, elevationClient = null) {

      this.v0 = v0.clone().normalize();
      this.v1 = v1.clone().normalize();
      this.v2 = v2.clone().normalize();
      this.level = level;
      this.index = index;
      this.parent = parent;
      this.radius = radius;
      this.elevationClient = elevationClient;

      this.children = null;
      this.geometry = null;
      this.mesh = null;
      this.baseDirs = null;
      this.positionAttr = null;

      this.centerDir = new THREE.Vector3()
        .add(this.v0)
        .add(this.v1)
        .add(this.v2)
        .normalize();
      this.center = this.centerDir.clone().multiplyScalar(this.radius);

      const a0 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v0), -1, 1));
      const a1 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v1), -1, 1));
      const a2 = Math.acos(THREE.MathUtils.clamp(this.centerDir.dot(this.v2), -1, 1));
      this.angularRadius = Math.max(a0, a1, a2);

      // imagery state
      this.imageryVersion = null;
      this.imageryZoom = null;
      this.imageryTileX = null;
      this.imageryTileY = null;
      this.imageryReady = false;
    }

    subdivide() {
      if (this.children) return this.children;

      const mid01 = new THREE.Vector3().addVectors(this.v0, this.v1).normalize();
      const mid12 = new THREE.Vector3().addVectors(this.v1, this.v2).normalize();
      const mid20 = new THREE.Vector3().addVectors(this.v2, this.v0).normalize();

      const childLevel = this.level + 1;
      this.children = [
        new TriTile(mid01, mid12, mid20, childLevel, this.index * 4,     this, this.radius, this.elevationClient),
        new TriTile(this.v0, mid01, mid20, childLevel, this.index * 4+1, this, this.radius, this.elevationClient),
        new TriTile(this.v1, mid12, mid01, childLevel, this.index * 4+2, this, this.radius, this.elevationClient),
        new TriTile(this.v2, mid20, mid12, childLevel, this.index * 4+3, this, this.radius, this.elevationClient),
      ];
      return this.children;
    }

    buildGeometry() {
      if (this.geometry) return this.geometry;

      const baseRes = 3;
      const resPerLevel = 2;
      const res = Math.min(baseRes + this.level * resPerLevel, 13);

      const vertices = [];
      const dirs = [];
      const indices = [];

      const v0 = this.v0;
      const v1 = this.v1;
      const v2 = this.v2;

      let idx = 0;
      for (let i = 0; i <= res; i++) {
        for (let j = 0; j <= res - i; j++) {
          const k = res - i - j;
          const w0 = i / res;
          const w1 = j / res;
          const w2 = k / res;

          let px = w0 * v0.x + w1 * v1.x + w2 * v2.x;
          let py = w0 * v0.y + w1 * v1.y + w2 * v2.y;
          let pz = w0 * v0.z + w1 * v1.z + w2 * v2.z;

          const len = Math.sqrt(px*px + py*py + pz*pz) || 1;
          px /= len; py /= len; pz /= len;

          const dir = new THREE.Vector3(px, py, pz);

          const r = this.radius;
          vertices.push(dir.x * r, dir.y * r, dir.z * r);
          dirs.push(dir.x, dir.y, dir.z);

          if (this.elevationClient) {
            const { latDeg, lonDeg } = dirToLatLon(dir);
            this.elevationClient.registerVertex(latDeg, lonDeg, dir.clone(), this, idx);
          }

          idx++;
        }
      }

      let vIdx = 0;
      for (let i = 0; i < res; i++) {
        const rowStart = vIdx;
        const rowLen = res - i + 1;
        const nextRowStart = vIdx + rowLen;

        for (let j = 0; j < res - i; j++) {
          const a = rowStart + j;
          const b = rowStart + j + 1;
          const c = nextRowStart + j;

          indices.push(a, b, c);

          if (j < res - i - 1) {
            const d = nextRowStart + j + 1;
            indices.push(b, d, c);
          }
        }

        vIdx = nextRowStart;
      }

      const positionArray = new Float32Array(vertices);
      const baseDirArray = new Float32Array(dirs);
      const indexArray = new Uint32Array(indices);

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
      geom.setIndex(new THREE.BufferAttribute(indexArray, 1));
      geom.computeVertexNormals();
      geom.attributes.position.setUsage(THREE.DynamicDrawUsage);

      this.geometry = geom;
      this.baseDirs = baseDirArray;
      this.positionAttr = geom.getAttribute('position');

      return geom;
    }

    ensureMesh(parent, baseMaterial) {
      if (!this.mesh) {
        this.buildGeometry();
        const mat = baseMaterial.clone();
        this.mesh = new THREE.Mesh(this.geometry, mat);
        this.mesh.castShadow = false;
        this.mesh.receiveShadow = false;
        parent.add(this.mesh);
      }
    }

    setVisible(visible) {
      if (this.mesh) this.mesh.visible = visible;
    }

    destroyChildren(group) {
      if (!this.children) return 0;
      let count = 0;
      const stack = [...this.children];
      while (stack.length) {
        const t = stack.pop();
        if (t.children) stack.push(...t.children);
        if (t.mesh) {
          group.remove(t.mesh);
          if (t.mesh.geometry) t.mesh.geometry.dispose();
          t.mesh.geometry = null;
          t.mesh.material = null;
          t.mesh = null;
        }
        t.geometry = null;
        t.baseDirs = null;
        t.positionAttr = null;
        t.children = null;
        t.clearImagery();
        count++;
      }
      this.children = null;
      return count;
    }

    updateVertex(index, elevMeters) {
      if (!this.positionAttr || !this.baseDirs) return;
      const base = this.baseDirs;
      const pos = this.positionAttr.array;

      const bx = base[index*3 + 0];
      const by = base[index*3 + 1];
      const bz = base[index*3 + 2];

      const rel = (elevMeters * ELEVATION_EXAGGERATION) / EARTH_RADIUS_M;
      const r = this.radius * (1 + rel);

      pos[index*3 + 0] = bx * r;
      pos[index*3 + 1] = by * r;
      pos[index*3 + 2] = bz * r;

      this.positionAttr.needsUpdate = true;
      tilesPendingNormals.add(this);
    }

    clearImagery() {
      this.imageryVersion = null;
      this.imageryZoom = null;
      this.imageryTileX = null;
      this.imageryTileY = null;
      this.imageryReady = false;
      if (this.mesh && this.mesh.material) {
        this.mesh.material.map = null;
        this.mesh.material.needsUpdate = true;
      }
    }

    ensureImagery(imageryManager, config) {
      if (!imageryManager || !config || !config.enabled) return;
      if (!this.mesh || !this.baseDirs || !this.geometry) return;

      const { versionId, zoom } = config;
      if (this.imageryReady &&
          this.imageryVersion === versionId &&
          this.imageryZoom === zoom) {
        return;
      }

      this.imageryVersion = versionId;
      this.imageryZoom = zoom;
      this.imageryReady = false;

      const { latDeg: cLat, lonDeg: cLon } = dirToLatLon(this.centerDir);
      const centerCoords = lonLatToTileCoords(cLon, cLat, zoom);
      this.imageryTileX = centerCoords.x;
      this.imageryTileY = centerCoords.y;

      const vxCount = this.baseDirs.length / 3;
      const uvArray = new Float32Array(vxCount * 2);
      const tmpDir = new THREE.Vector3();

      for (let i = 0; i < vxCount; i++) {
        const bx = this.baseDirs[i*3 + 0];
        const by = this.baseDirs[i*3 + 1];
        const bz = this.baseDirs[i*3 + 2];
        tmpDir.set(bx, by, bz);
        const { latDeg, lonDeg } = dirToLatLon(tmpDir);
        const c = lonLatToTileCoords(lonDeg, latDeg, zoom);
        let u = c.cx - this.imageryTileX;
        let v = c.cy - this.imageryTileY;
        u = THREE.MathUtils.clamp(u, 0, 1);
        v = THREE.MathUtils.clamp(v, 0, 1);
        uvArray[i*2 + 0] = u;
        uvArray[i*2 + 1] = 1 - v; // flip V for texture space
      }

      this.geometry.setAttribute('uv', new THREE.BufferAttribute(uvArray, 2));
      this.geometry.attributes.uv.needsUpdate = true;

      imageryManager.getTile(this.imageryTileX, this.imageryTileY, zoom)
        .then(tex => {
          if (!tex || !this.mesh || !this.mesh.material) return;
          this.mesh.material.map = tex;
          this.mesh.material.needsUpdate = true;
          this.imageryReady = true;
        })
        .catch(err => {
          console.error('[imagery] apply failed', err);
        });
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Icosahedron ‚Üí root tiles
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function createIcosahedronTiles(radius, elevationClient) {
    const t = (1 + Math.sqrt(5)) / 2;
    const verts = [
      new THREE.Vector3(-1,  t,  0).normalize(),
      new THREE.Vector3( 1,  t,  0).normalize(),
      new THREE.Vector3(-1, -t,  0).normalize(),
      new THREE.Vector3( 1, -t,  0).normalize(),

      new THREE.Vector3( 0, -1,  t).normalize(),
      new THREE.Vector3( 0,  1,  t).normalize(),
      new THREE.Vector3( 0, -1, -t).normalize(),
      new THREE.Vector3( 0,  1, -t).normalize(),

      new THREE.Vector3( t,  0, -1).normalize(),
      new THREE.Vector3( t,  0,  1).normalize(),
      new THREE.Vector3(-t,  0, -1).normalize(),
      new THREE.Vector3(-t,  0,  1).normalize(),
    ];

    const faces = [
      [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
      [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
      [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
      [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1],
    ];

    const tiles = [];
    for (let i = 0; i < faces.length; i++) {
      const [i0, i1, i2] = faces[i];
      tiles.push(
        new TriTile(verts[i0], verts[i1], verts[i2], 0, i, null, radius, elevationClient)
      );
    }
    return tiles;
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Tritree manager (LOD + budgets + imagery)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  class TriTreeManager {
    constructor(scene, elevationClient, imageryManager, radius = PLANET_RADIUS) {
      this.scene = scene;
      this.radius = radius;
      this.elevationClient = elevationClient;
      this.imageryManager = imageryManager;

      this.group = new THREE.Group();
      this.group.name = 'PlanetGroup';
      this.scene.add(this.group);

      this.rootTiles = createIcosahedronTiles(radius, elevationClient);

      // Material will be set via setMaterial() after texture loading
      this.material = new THREE.MeshStandardMaterial({
        color: 0x4b5563,
        metalness: 0.0,
        roughness: 0.95,
        flatShading: false,
        side: THREE.DoubleSide,
      });

      this.visibleTileCount = 0;
      this.currentMaxLevel = 0;
      this.hexPatch = null;
      this.lodMode = 'orbit';
      this.viewFocusDir = null;

      this.tileBudget = 2000;
      this.splitBudget = 64;
      this.mergeBudget = 64;
      this.tileCount = this.rootTiles.length;

      for (const tile of this.rootTiles) {
        tile.ensureMesh(this.group, this.material);
        tile.setVisible(true);
      }
    }

    setHexPatch(centerDir, radius) {
      if (!centerDir || !Number.isFinite(radius) || radius <= 0) {
        this.hexPatch = null;
      } else {
        this.hexPatch = {
          centerDir: centerDir.clone().normalize(),
          radius
        };
      }
    }

    setLODMode(mode) {
      this.lodMode = (mode === 'zoom') ? 'zoom' : 'orbit';
    }

    setBudgets({ tileBudget, splitBudget, mergeBudget }) {
      if (Number.isFinite(tileBudget) && tileBudget > 0) {
        this.tileBudget = Math.max(200, Math.min(8000, Math.floor(tileBudget)));
      }
      if (Number.isFinite(splitBudget) && splitBudget > 0) {
        this.splitBudget = Math.max(4, Math.min(256, Math.floor(splitBudget)));
      }
      if (Number.isFinite(mergeBudget) && mergeBudget > 0) {
        this.mergeBudget = Math.max(4, Math.min(256, Math.floor(mergeBudget)));
      }
    }

    setImageryConfig(config) {
      if (!this.imageryManager) return;
      this.imageryManager.setConfig(config || {});
      // Clear imagery so tiles rebind to new version / zoom
      const stack = [...this.rootTiles];
      while (stack.length) {
        const t = stack.pop();
        t.clearImagery();
        if (t.children) stack.push(...t.children);
      }
    }

    setMaterial(newMaterial) {
      // Update material reference
      this.material = newMaterial;

      // Update all existing tile meshes
      const stack = [...this.rootTiles];
      while (stack.length) {
        const tile = stack.pop();
        if (tile.mesh) {
          tile.mesh.material = newMaterial;
        }
        if (tile.children) {
          stack.push(...tile.children);
        }
      }
    }

    _desiredLevelForTile(tile, camera) {
      const dist = camera.position.length();
      const altUnits = dist - this.radius;

      let baseLevel = 0;

      if (this.lodMode === 'orbit') {
        const camDir = camera.position.clone().normalize();
        const dotCam = THREE.MathUtils.clamp(tile.centerDir.dot(camDir), -1, 1);
        const angleToCam = Math.acos(dotCam);
        const angleDeg = angleToCam * RAD2DEG;

        if (angleDeg < 12) baseLevel = 5;
        else if (angleDeg < 25) baseLevel = 4;
        else if (angleDeg < 45) baseLevel = 3;
        else if (angleDeg < 65) baseLevel = 2;
        else if (angleDeg < 85) baseLevel = 1;
        else baseLevel = 0;

        if (altUnits < 150_000) baseLevel += 1;
        if (altUnits < 50_000)  baseLevel += 1;
        if (altUnits > 1_000_000) baseLevel -= 1;
        if (altUnits > 3_000_000) baseLevel -= 1;

      } else {
        const focusDir = this.viewFocusDir || camera.position.clone().normalize();
        const dotF = THREE.MathUtils.clamp(tile.centerDir.dot(focusDir), -1, 1);
        const angleToFocus = Math.acos(dotF);

        const fovRad = camera.fov * DEG2RAD;
        const halfFov = fovRad * 0.5;
        const tileAngle = tile.angularRadius * 2;

        if (angleToFocus - tile.angularRadius > halfFov * 1.2) {
          baseLevel = 0;
        } else {
          const approxPix = (tileAngle / fovRad) * viewportHeight;

          if (approxPix < 6) baseLevel = 0;
          else if (approxPix < 15) baseLevel = 1;
          else if (approxPix < 40) baseLevel = 2;
          else if (approxPix < 120) baseLevel = 3;
          else if (approxPix < 260) baseLevel = 4;
          else baseLevel = 5;

          if (altUnits < 200_000) baseLevel += 1;
          if (altUnits < 60_000)  baseLevel += 1;
        }
      }

      // Hex patch focus
      let levelFromPatch = 0;
      const patch = this.hexPatch;
      if (patch && patch.centerDir) {
        const dotP = THREE.MathUtils.clamp(tile.centerDir.dot(patch.centerDir), -1, 1);
        const angleToPatch = Math.acos(dotP);

        if (angleToPatch - tile.angularRadius <= patch.radius * 1.1) {
          if (angleToPatch < patch.radius * 0.3) levelFromPatch = MAX_TILE_LEVEL;
          else if (angleToPatch < patch.radius * 0.6) levelFromPatch = Math.max(4, MAX_TILE_LEVEL - 1);
          else levelFromPatch = 3;
        }
      }

      let desired = Math.max(baseLevel, levelFromPatch);
      desired = Math.max(0, Math.min(MAX_TILE_LEVEL, desired));
      return desired;
    }

    update(camera) {
      const viewDir = new THREE.Vector3();
      camera.getWorldDirection(viewDir);
      const hit = raySphereIntersection(camera.position, viewDir);
      this.viewFocusDir = hit ? hit.clone().normalize() : camera.position.clone().normalize();

      this.visibleTileCount = 0;
      this.currentMaxLevel = 0;

      const tilesToSplit = [];
      const tilesToMerge = [];
      const HYST = 1;

      const visit = (tile) => {
        const desired = this._desiredLevelForTile(tile, camera);
        this.currentMaxLevel = Math.max(this.currentMaxLevel, tile.level);

        if (tile.children) {
          if (tile.level >= desired + HYST) {
            tilesToMerge.push(tile);
          }
          tile.setVisible(false);
          for (const child of tile.children) visit(child);
        } else {
          tile.ensureMesh(this.group, this.material);
          tile.setVisible(true);
          this.visibleTileCount++;

          if (this.imageryManager && this.imageryManager.enabled) {
            tile.ensureImagery(this.imageryManager, this.imageryManager.getConfig());
          }

          if (tile.level < desired && tile.level < MAX_TILE_LEVEL) {
            const priority = (desired - tile.level) + 0.1 * (MAX_TILE_LEVEL - tile.level);
            tilesToSplit.push({ tile, priority });
          }
        }
      };

      for (const root of this.rootTiles) {
        visit(root);
      }

      if (tilesToMerge.length) {
        tilesToMerge.sort((a, b) => b.level - a.level);
        let mergesDone = 0;
        for (const tile of tilesToMerge) {
          if (mergesDone >= this.mergeBudget && this.tileCount <= this.tileBudget) break;
          if (!tile.children) continue;
          const removed = tile.destroyChildren(this.group);
          this.tileCount -= removed;
          mergesDone++;
        }
      }

      if (tilesToSplit.length && this.tileCount < this.tileBudget) {
        tilesToSplit.sort((a, b) => b.priority - a.priority);
        let splitsDone = 0;
        const maxSplitsPossible = Math.floor((this.tileBudget - this.tileCount) / 4);
        const splitLimit = Math.min(this.splitBudget, maxSplitsPossible);

        for (const { tile } of tilesToSplit) {
          if (splitsDone >= splitLimit) break;
          if (tile.children) continue;
          tile.subdivide();
          this.tileCount += tile.children.length;
          splitsDone++;
        }
      }
    }
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Globals for scene / hex selection
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  let triTree = null;

  const clickRaycaster = new THREE.Raycaster();
  const clickNDC = new THREE.Vector2();

  const hexSelection = {
    centerDir: null,
    radius: 5 * DEG2RAD
  };

  function isEditableTarget(el) {
    if (!el) return false;
    const tag = (el.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
    if (el.isContentEditable) return true;
    if (el.getAttribute && el.getAttribute('contenteditable') === 'true') return true;
    return false;
  }

  function getSphereIntersectionFromEvent(e, renderer, camera) {
    const rect = renderer.domElement.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    clickNDC.set(x, y);

    clickRaycaster.setFromCamera(clickNDC, camera);
    return raySphereIntersection(clickRaycaster.ray.origin, clickRaycaster.ray.direction);
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Main scene setup
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  window.addEventListener('load', () => {
    const container = document.getElementById('three-container');
    const metricTiles = document.getElementById('metric-tiles');
    const metricLevel = document.getElementById('metric-level');
    const metricHex = document.getElementById('metric-hex');
    const metricBatches = document.getElementById('metric-batches');
    const metricVerts = document.getElementById('metric-verts');
    const metricLatLon = document.getElementById('metric-latlon');

    const metricReqs = document.getElementById('metric-reqs');
    const metricResps = document.getElementById('metric-resps');
    const metricKBOut = document.getElementById('metric-kbout');
    const metricKBIn = document.getElementById('metric-kbin');
    const metricPtsOut = document.getElementById('metric-points-out');
    const metricPtsIn = document.getElementById('metric-points-in');
    const metricRatio = document.getElementById('metric-ratio');

    const relayEl = document.getElementById('relay');
    const datasetEl = document.getElementById('dataset');
    const myAddrEl = document.getElementById('myAddr');
    const sdkStatusEl = document.getElementById('sdkStatus');
    const connStatusEl = document.getElementById('connStatus');

    const btnLodOrbit = document.getElementById('btnLodOrbit');
    const btnLodZoom = document.getElementById('btnLodZoom');

    const debugToggle = document.getElementById('debug-toggle');
    const debugPanel = document.getElementById('debug-panel');

    const sidebarToggle = document.getElementById('sidebar-toggle');
    const sidebar = document.getElementById('sidebar');
    const sidebarClose = document.getElementById('sidebar-close');
    const sidebarTabs = Array.from(document.querySelectorAll('.sidebar-tab'));
    const sidebarPages = Array.from(document.querySelectorAll('.sidebar-page'));

    const cfgBatchSize = document.getElementById('cfg-batchSize');
    const cfgMaxConcurrent = document.getElementById('cfg-maxConcurrent');
    const cfgMinInterval = document.getElementById('cfg-minInterval');
    const cfgMaxKBPerMin = document.getElementById('cfg-maxKBPerMin');

    const cfgTileBudget = document.getElementById('cfg-tileBudget');
    const cfgSplitBudget = document.getElementById('cfg-splitBudget');
    const cfgMergeBudget = document.getElementById('cfg-mergeBudget');

    const cfgImageryEnabled = document.getElementById('cfg-imageryEnabled');
    const cfgImageryVersion = document.getElementById('cfg-imageryVersion');
    const cfgImageryZoom = document.getElementById('cfg-imageryZoom');
    const btnImageryPreview = document.getElementById('btnImageryPreview');
    const imageryPreviewImg = document.getElementById('imageryPreview');
    const imageryUrlEl = document.getElementById('imageryUrl');

    // Lighting / Time controls
    const cfgDate = document.getElementById('cfg-date');
    const cfgTime = document.getElementById('cfg-time');
    const cfgTimeSpeed = document.getElementById('cfg-timeSpeed');
    const cfgTimeSpeedLabel = document.getElementById('cfg-timeSpeedLabel');
    const cfgUseSimplified = document.getElementById('cfg-useSimplified');
    const cfgAtmDayColor = document.getElementById('cfg-atmDayColor');
    const cfgAtmTwilightColor = document.getElementById('cfg-atmTwilightColor');
    const cfgAtmosphereEnabled = document.getElementById('cfg-atmosphereEnabled');
    const btnTimeNow = document.getElementById('btn-timeNow');
    const btnTimeSunrise = document.getElementById('btn-timeSunrise');
    const btnTimeNoon = document.getElementById('btn-timeNoon');
    const btnTimeSunset = document.getElementById('btn-timeSunset');
    const btnTimeMidnight = document.getElementById('btn-timeMidnight');
    const metricCurrentTime = document.getElementById('metric-currentTime');
    const metricSunDir = document.getElementById('metric-sunDir');

    const LS_RELAY = 'nkn.globe.relay';
    const LS_DATASET = 'nkn.globe.dataset';

    relayEl.value = localStorage.getItem(LS_RELAY) || DEFAULT_FORWARDER;
    datasetEl.value = localStorage.getItem(LS_DATASET) || 'mapzen';

    function setSDKStatus(ok, text) {
      if (ok) {
        sdkStatusEl.innerHTML = '<span class="ok">' + (text || 'nkn-sdk loaded') + '</span>';
      } else {
        sdkStatusEl.innerHTML = '<span class="bad">' + (text || 'nkn-sdk not loaded') + '</span>';
      }
    }
    function setConnStatus(ok, text) {
      if (ok) {
        connStatusEl.innerHTML = '<span class="ok">' + (text || 'connected') + '</span>';
      } else {
        connStatusEl.innerHTML = '<span class="bad">' + (text || 'not connected') + '</span>';
      }
    }

    // Sidebar behavior
    function openSidebar() {
      sidebar.classList.add('open');
      sidebarToggle.classList.add('open');
    }
    function closeSidebar() {
      sidebar.classList.remove('open');
      sidebarToggle.classList.remove('open');
    }
    sidebarToggle.addEventListener('click', () => {
      if (sidebar.classList.contains('open')) closeSidebar();
      else openSidebar();
    });
    sidebarClose.addEventListener('click', closeSidebar);

    sidebarTabs.forEach(btn => {
      btn.addEventListener('click', () => {
        const tab = btn.dataset.tab;
        sidebarTabs.forEach(b => b.classList.toggle('active', b === btn));
        sidebarPages.forEach(page => {
          page.classList.toggle('active', page.dataset.page === tab);
        });
      });
    });

    // Renderer / scene / camera (WebGL2 with logarithmic depth for astronomical scale)
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      logarithmicDepthBuffer: true // Required for Earth-Sun scale (1m to 150M km)
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    container.appendChild(renderer.domElement);
    renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#020617');

    const camera = new THREE.PerspectiveCamera(
      45,
      container.clientWidth / container.clientHeight,
      CAMERA_NEAR,
      CAMERA_FAR
    );
    camera.position.set(0, 0, PLANET_RADIUS * 3);
    camera.lookAt(0, 0, 0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = PLANET_RADIUS * 1.0001; // Very close to surface
    controls.maxDistance = PLANET_RADIUS * 10.0;
    controls.target.set(0, 0, 0);
    controls.enablePan = false; // Keep focus on globe center

    // Dynamic lighting system with real astronomical distances
    const lightingSystem = new LightingSystem(scene, PLANET_RADIUS, SUN_EARTH_DISTANCE_M);

    // Initialize with current time
    lightingSystem.updateSunPosition(new Date());

    // Set time speed (0 = paused, 1 = real-time, 60 = 1 minute per second, etc.)
    lightingSystem.setTimeSpeed(0); // Start paused, can be controlled via UI

    // Add visual sun sphere at real size and distance
    const sunGeometry = new THREE.SphereGeometry(SUN_RADIUS_M, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({
      color: '#FDB813',
      emissive: '#FDB813',
      emissiveIntensity: 1.0
    });
    const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
    sunMesh.name = 'SunVisual';
    scene.add(sunMesh);

    // Function to update sun visual position to match light
    function updateSunVisual() {
      sunMesh.position.copy(lightingSystem.sun.position);
    }
    updateSunVisual();

    const elevationClient = new ElevationClient();
    const imageryManager = new ImageryManager();
    triTree = new TriTreeManager(scene, elevationClient, imageryManager, PLANET_RADIUS);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Load Earth textures and create TSL materials (async)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let atmosphereMesh = null;

    (async function initEarthMaterials() {
      try {
        console.log('Loading Earth textures...');
        const textures = await loadEarthTexturesWithFallback('./textures/', '4096');

        if (textures.usingFallback) {
          console.warn('Using fallback textures - download real textures for better visuals');
        }

        // Create Earth material with TSL shaders
        const earthMaterial = createEarthMaterial(textures, lightingSystem.sun, {
          atmosphereDayColor: '#4db2ff',
          atmosphereTwilightColor: '#bc490b',
          roughnessLow: 0.25,
          roughnessHigh: 0.35
        });

        // Update all tiles to use new material
        triTree.setMaterial(earthMaterial);

        // Create atmosphere shell
        const atmosphereGeometry = new THREE.SphereGeometry(PLANET_RADIUS, 64, 64);
        const atmosphereMaterial = createAtmosphereMaterial(
          { day: '#4db2ff', twilight: '#bc490b' },
          lightingSystem.sun
        );

        atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        atmosphereMesh.scale.setScalar(1.04);
        atmosphereMesh.name = 'Atmosphere';
        scene.add(atmosphereMesh);

        console.log('Earth materials initialized successfully');
      } catch (error) {
        console.error('Failed to initialize Earth materials:', error);
      }
    })();

    // Hex selector visualization
    const hexGeometry = new THREE.BufferGeometry();
    const hexMaterial = new THREE.LineBasicMaterial({ color: 0x22d3ee });
    const hexLine = new THREE.LineLoop(hexGeometry, hexMaterial);
    hexLine.visible = false;
    scene.add(hexLine);

    function updateHexVisualization() {
      const patch = hexSelection;
      if (!patch.centerDir) {
        hexLine.visible = false;
        metricHex.textContent = 'none';
        triTree.setHexPatch(null, 0);
        return;
      }

      const segments = 6;
      const positions = new Float32Array((segments + 1) * 3);
      const c = patch.centerDir.clone().normalize();
      const r = patch.radius;

      let up = new THREE.Vector3(0, 1, 0);
      if (Math.abs(up.dot(c)) > 0.98) up = new THREE.Vector3(1, 0, 0);
      const east = new THREE.Vector3().crossVectors(up, c).normalize();
      const north = new THREE.Vector3().crossVectors(c, east).normalize();

      for (let k = 0; k < segments; k++) {
        const phi = (Math.PI / 3) * k;
        const tangent = new THREE.Vector3()
          .copy(east).multiplyScalar(Math.cos(phi))
          .add(new THREE.Vector3().copy(north).multiplyScalar(Math.sin(phi)));

        const dir = new THREE.Vector3()
          .copy(c).multiplyScalar(Math.cos(r))
          .add(tangent.multiplyScalar(Math.sin(r)))
          .normalize();

        const i3 = k * 3;
        const scale = PLANET_RADIUS * 1.001;
        positions[i3 + 0] = dir.x * scale;
        positions[i3 + 1] = dir.y * scale;
        positions[i3 + 2] = dir.z * scale;

        if (k === 0) {
          const j3 = segments * 3;
          positions[j3 + 0] = positions[i3 + 0];
          positions[j3 + 1] = positions[i3 + 1];
          positions[j3 + 2] = positions[i3 + 2];
        }
      }

      hexGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      hexGeometry.computeBoundingSphere();
      hexLine.visible = true;

      metricHex.textContent = (patch.radius / DEG2RAD).toFixed(1) + '¬∞';
      triTree.setHexPatch(hexSelection.centerDir, hexSelection.radius);
    }

    function setHexSelection(dir) {
      hexSelection.centerDir = dir.clone().normalize();
      hexSelection.radius = 5 * DEG2RAD;
      updateHexVisualization();
    }

    // Auto tilt when approaching the globe
    function autoTilt(camera, controls) {
      const dist = camera.position.length();
      const altUnits = dist - PLANET_RADIUS;

      if (altUnits <= ALT_30K_UNITS) {
        const up = camera.position.clone().normalize();
        const down = up.clone().multiplyScalar(-1);
        let tangent = new THREE.Vector3().crossVectors(up, new THREE.Vector3(0, 1, 0));
        if (tangent.lengthSq() < 1e-6) tangent.set(1, 0, 0);
        tangent.normalize();

        let pitchAngle = 0;
        if (altUnits <= ALT_10K_UNITS) {
          pitchAngle = Math.PI / 2;
        } else {
          const t = (ALT_30K_UNITS - altUnits) / (ALT_30K_UNITS - ALT_10K_UNITS);
          const clamped = THREE.MathUtils.clamp(t, 0, 1);
          pitchAngle = clamped * (Math.PI / 2);
        }

        const lookDir = down.multiplyScalar(Math.cos(pitchAngle))
          .add(tangent.multiplyScalar(Math.sin(pitchAngle)))
          .normalize();

        const target = camera.position.clone().add(lookDir);
        controls.target.copy(target);
        controls.update();
      }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NKN init & wiring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function updateRelayDataset() {
      const relay = (relayEl.value.trim() || DEFAULT_FORWARDER);
      const dataset = datasetEl.value.trim() || 'mapzen';
      relayEl.value = relay;
      localStorage.setItem(LS_RELAY, relay);
      localStorage.setItem(LS_DATASET, dataset);
      elevationClient.setRelayAndDataset(relay, dataset);
    }

    relayEl.addEventListener('input', updateRelayDataset);
    relayEl.addEventListener('change', updateRelayDataset);
    datasetEl.addEventListener('input', updateRelayDataset);
    datasetEl.addEventListener('change', updateRelayDataset);
    updateRelayDataset();

    let mc = null;

    function initNKN() {
      if (!window.nkn || !nkn.MultiClient) {
        setSDKStatus(false, 'nkn-sdk not loaded (check CDN)');
        return;
      }
      setSDKStatus(true, 'nkn-sdk loaded');
      try {
        mc = new nkn.MultiClient({ numSubClients: 4, originalClient: false });
      } catch (e) {
        setConnStatus(false, 'failed to create MultiClient');
        console.error('NKN init error', e);
        return;
      }

      myAddrEl.textContent = '‚Ä¶';
      setConnStatus(false, 'connecting‚Ä¶');

      mc.onConnect(() => {
        myAddrEl.textContent = mc.addr;
        setConnStatus(true, 'connected');
        elevationClient.setMultiClient(mc);
        console.log('‚úÖ NKN connected as', mc.addr);
      });

      mc.onMessage(({ src, payload }) => handleIncoming(src, payload));
    }

    initNKN();

    // Elevation config inputs
    function applyElevConfigFromUI() {
      const batchSize = parseInt(cfgBatchSize.value, 10);
      const maxConcurrent = parseInt(cfgMaxConcurrent.value, 10);
      const minInterval = parseInt(cfgMinInterval.value, 10);
      const maxKB = parseInt(cfgMaxKBPerMin.value, 10);
      elevationClient.setConfig({
        batchSize,
        maxConcurrent,
        minIntervalMs: minInterval,
        maxKBPerMinute: maxKB
      });
    }
    cfgBatchSize.addEventListener('change', applyElevConfigFromUI);
    cfgMaxConcurrent.addEventListener('change', applyElevConfigFromUI);
    cfgMinInterval.addEventListener('change', applyElevConfigFromUI);
    cfgMaxKBPerMin.addEventListener('change', applyElevConfigFromUI);
    applyElevConfigFromUI();

    // LOD mode
    let lodMode = 'orbit';
    function updateLodButtons() {
      btnLodOrbit.classList.toggle('active', lodMode === 'orbit');
      btnLodZoom.classList.toggle('active', lodMode === 'zoom');
    }
    btnLodOrbit.addEventListener('click', () => {
      lodMode = 'orbit';
      triTree.setLODMode('orbit');
      updateLodButtons();
    });
    btnLodZoom.addEventListener('click', () => {
      lodMode = 'zoom';
      triTree.setLODMode('zoom');
      updateLodButtons();
    });
    updateLodButtons();

    // LOD budgets
    cfgTileBudget.value = triTree.tileBudget;
    cfgSplitBudget.value = triTree.splitBudget;
    cfgMergeBudget.value = triTree.mergeBudget;
    function applyLodBudgetsFromUI() {
      const tileBudget = parseInt(cfgTileBudget.value, 10);
      const splitBudget = parseInt(cfgSplitBudget.value, 10);
      const mergeBudget = parseInt(cfgMergeBudget.value, 10);
      triTree.setBudgets({ tileBudget, splitBudget, mergeBudget });
    }
    cfgTileBudget.addEventListener('change', applyLodBudgetsFromUI);
    cfgSplitBudget.addEventListener('change', applyLodBudgetsFromUI);
    cfgMergeBudget.addEventListener('change', applyLodBudgetsFromUI);

    // Imagery config
    function applyImageryConfigFromUI() {
      const enabled = cfgImageryEnabled.checked;
      const versionId = cfgImageryVersion.value.trim() || '49849';
      const zoom = parseInt(cfgImageryZoom.value, 10);
      cfgImageryVersion.value = versionId;
      triTree.setImageryConfig({ enabled, versionId, zoom });
    }
    cfgImageryEnabled.addEventListener('change', applyImageryConfigFromUI);
    cfgImageryVersion.addEventListener('change', applyImageryConfigFromUI);
    cfgImageryZoom.addEventListener('change', applyImageryConfigFromUI);
    applyImageryConfigFromUI();

    btnImageryPreview.addEventListener('click', () => {
      const cfg = imageryManager.getConfig();
      const enabled = cfg.enabled;
      const z = cfg.zoom;
      if (!enabled) {
        imageryPreviewImg.removeAttribute('src');
        imageryUrlEl.textContent = 'Imagery disabled.';
        return;
      }
      const viewDir = new THREE.Vector3();
      camera.getWorldDirection(viewDir);
      const hit = raySphereIntersection(camera.position, viewDir);
      if (!hit) {
        imageryPreviewImg.removeAttribute('src');
        imageryUrlEl.textContent = 'Camera not intersecting globe.';
        return;
      }
      const ll = worldPosToLatLon(hit);
      if (!ll) {
        imageryPreviewImg.removeAttribute('src');
        imageryUrlEl.textContent = 'Lat/lon unavailable.';
        return;
      }
      const coords = lonLatToTileCoords(ll.lonDeg, ll.latDeg, z);
      const url = imageryManager.buildUrl(cfg.versionId, z, coords.x, coords.y);
      imageryPreviewImg.src = url + (url.includes('?') ? '&' : '?') + 'ts=' + Date.now();
      imageryUrlEl.textContent =
        `z/x/y: ${z}/${coords.x}/${coords.y} ¬∑ center: ${ll.latDeg.toFixed(6)}, ${ll.lonDeg.toFixed(6)}\n` +
        url;
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // Lighting / Time UI Controls
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Initialize date/time inputs with current values
    function updateTimeInputsFromLighting() {
      const timeInfo = lightingSystem.getTimeInfo();
      const date = timeInfo.date;

      cfgDate.valueAsDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      cfgTime.value = `${String(date.getUTCHours()).padStart(2, '0')}:${String(date.getUTCMinutes()).padStart(2, '0')}`;
      cfgTimeSpeed.value = lightingSystem.timeSpeed;

      // Update label
      if (lightingSystem.timeSpeed === 0) {
        cfgTimeSpeedLabel.textContent = 'Paused';
      } else if (lightingSystem.timeSpeed === 1) {
        cfgTimeSpeedLabel.textContent = 'Real-time';
      } else {
        cfgTimeSpeedLabel.textContent = `${lightingSystem.timeSpeed}√ó`;
      }
    }
    updateTimeInputsFromLighting();

    // Date/time change handlers
    cfgDate.addEventListener('change', () => {
      const newDate = new Date(lightingSystem.currentDate);
      const inputDate = cfgDate.valueAsDate;
      if (inputDate) {
        newDate.setUTCFullYear(inputDate.getFullYear());
        newDate.setUTCMonth(inputDate.getMonth());
        newDate.setUTCDate(inputDate.getDate());
        lightingSystem.setDate(newDate);
      }
    });

    cfgTime.addEventListener('change', () => {
      if (cfgTime.value) {
        const [hours, minutes] = cfgTime.value.split(':').map(Number);
        lightingSystem.setTimeOfDay(hours, minutes || 0);
      }
    });

    cfgTimeSpeed.addEventListener('input', () => {
      const speed = parseFloat(cfgTimeSpeed.value) || 0;
      lightingSystem.setTimeSpeed(speed);
      updateTimeInputsFromLighting();
    });

    cfgUseSimplified.addEventListener('change', () => {
      lightingSystem.setSimplifiedMode(cfgUseSimplified.checked);
    });

    // Time preset buttons
    btnTimeNow.addEventListener('click', () => {
      lightingSystem.setDate(new Date());
      updateTimeInputsFromLighting();
    });

    btnTimeSunrise.addEventListener('click', () => {
      lightingSystem.setTimeOfDay(6, 0);
      updateTimeInputsFromLighting();
    });

    btnTimeNoon.addEventListener('click', () => {
      lightingSystem.setTimeOfDay(12, 0);
      updateTimeInputsFromLighting();
    });

    btnTimeSunset.addEventListener('click', () => {
      lightingSystem.setTimeOfDay(18, 0);
      updateTimeInputsFromLighting();
    });

    btnTimeMidnight.addEventListener('click', () => {
      lightingSystem.setTimeOfDay(0, 0);
      updateTimeInputsFromLighting();
    });

    // Atmosphere controls
    cfgAtmosphereEnabled.addEventListener('change', () => {
      if (atmosphereMesh) {
        atmosphereMesh.visible = cfgAtmosphereEnabled.checked;
      }
    });

    cfgAtmDayColor.addEventListener('change', () => {
      // Update atmosphere colors (will be implemented when materials are loaded)
      console.log('Atmosphere day color:', cfgAtmDayColor.value);
    });

    cfgAtmTwilightColor.addEventListener('change', () => {
      console.log('Atmosphere twilight color:', cfgAtmTwilightColor.value);
    });

    // Debug toggle
    debugToggle.addEventListener('click', () => {
      perf.enabled = !perf.enabled;
      debugToggle.classList.toggle('active', perf.enabled);
      debugPanel.classList.toggle('open', perf.enabled);
      if (perf.enabled) {
        perf.sections = {};
        perf.lastPanelUpdate = 0;
      }
    });

    // Pointer: Shift+click to set hex patch
    renderer.domElement.addEventListener('pointerdown', (e) => {
      if (e.button !== 0) return;
      if (!e.shiftKey) return;
      if (isEditableTarget(e.target)) return;
      const hit = getSphereIntersectionFromEvent(e, renderer, camera);
      if (hit) {
        const dir = hit.clone().normalize();
        setHexSelection(dir);
      }
    });

    // Keyboard: Esc closes sidebar
    window.addEventListener('keydown', (e) => {
      if (isEditableTarget(e.target)) return;
      if (e.code === 'Escape') {
        if (sidebar.classList.contains('open')) {
          closeSidebar();
          e.preventDefault();
        }
      }
    });

    // Resize
    function onResize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      viewportHeight = h;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    window.addEventListener('resize', onResize);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Animation loop
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    let lastTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);

      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      if (perf.enabled) {
        perf.frameStart = performance.now();
      }

      perfStart('lighting');
      // Update sun position based on time progression
      lightingSystem.update(dt);
      updateSunVisual(); // Sync visual sun sphere with light position
      perfEnd('lighting');

      perfStart('controls');
      controls.update();
      autoTilt(camera, controls);
      perfEnd('controls');

      perfStart('lod');
      triTree.update(camera);
      perfEnd('lod');

      perfStart('elevation');
      elevationClient.updateCamera(camera);
      elevationClient.tick();
      perfEnd('elevation');

      perfStart('normals');
      if (tilesPendingNormals.size) {
        tilesPendingNormals.forEach(tile => {
          if (tile.geometry) tile.geometry.computeVertexNormals();
        });
        tilesPendingNormals.clear();
      }
      perfEnd('normals');

      perfStart('render');
      renderer.render(scene, camera);
      perfEnd('render');

      if (perf.enabled) {
        const frameDt = performance.now() - perf.frameStart;
        const sFrame = perf.sections.frame || (perf.sections.frame = {
          total:0,samples:0,last:0,max:0
        });
        sFrame.last = frameDt;
        sFrame.total += frameDt;
        sFrame.samples++;
        if (frameDt > sFrame.max) sFrame.max = frameDt;

        if (now - perf.lastPanelUpdate > 500) {
          perf.lastPanelUpdate = now;
          updateDebugPanel();
        }
      }

      const stats = elevationClient.getStats();
      metricTiles.textContent = triTree.visibleTileCount.toString();
      metricLevel.textContent = triTree.currentMaxLevel.toString();
      metricBatches.textContent = stats.currentBatches.toString();
      metricVerts.textContent = stats.totalVertices.toString();

      metricReqs.textContent = stats.requestCount.toString();
      metricResps.textContent = stats.responseCount.toString();
      metricPtsOut.textContent = stats.pointsRequested.toString();
      metricPtsIn.textContent = stats.pointsReceived.toString();
      metricKBOut.textContent = (stats.bytesOut / 1024).toFixed(1);
      metricKBIn.textContent = (stats.bytesIn / 1024).toFixed(1);
      if (stats.bytesOut > 0) {
        const ratio = stats.bytesIn / stats.bytesOut;
        metricRatio.textContent = ratio.toFixed(2);
      } else {
        metricRatio.textContent = '‚Äì';
      }

      // Update sun/time metrics
      const timeInfo = lightingSystem.getTimeInfo();
      const sunDir = lightingSystem.getSunDirection();
      metricCurrentTime.textContent = `${String(timeInfo.hours).padStart(2, '0')}:${String(timeInfo.minutes).padStart(2, '0')} UTC`;
      metricSunDir.textContent = `(${sunDir.x.toFixed(2)}, ${sunDir.y.toFixed(2)}, ${sunDir.z.toFixed(2)})`;

      // Lat/lon at view center
      let latlonStr = '‚Äì';
      const vDir = new THREE.Vector3();
      camera.getWorldDirection(vDir);
      const hit = raySphereIntersection(camera.position, vDir);
      if (hit) {
        const ll = worldPosToLatLon(hit);
        if (ll) {
          latlonStr = `${ll.latDeg.toFixed(4)}¬∞, ${ll.lonDeg.toFixed(4)}¬∞`;
        }
      }
      metricLatLon.textContent = latlonStr;
    }

    animate();
  });
</script>
</body>
</html>
